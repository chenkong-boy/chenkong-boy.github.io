<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>nginx-一篇通 | 晨空</title><meta name="keywords" content="nginx"><meta name="author" content="晨空"><meta name="copyright" content="晨空"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="nginx-一篇通"><meta name="application-name" content="nginx-一篇通"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="nginx-一篇通"><meta property="og:url" content="http://example.com/2024/05/17/nginx/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/index.html"><meta property="og:site_name" content="晨空"><meta property="og:description" content="nginx 一把梭！（超详细讲解+实操）原创 蝎子莱莱爱打怪 稀土掘金技术社区 2023-12-10 09:31 重庆 稀土掘金技术社区 掘金，一个帮助开发者成长的技术社区 740篇原创内容 前言：nginx作为当今火爆的、高性能的http及反向代理服务，不管前端还是后端，都需要全面去了解，学习，实"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/tupian/nginx-top.jpeg"><meta property="article:author" content="晨空"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/tupian/nginx-top.jpeg"><meta name="description" content="nginx 一把梭！（超详细讲解+实操）原创 蝎子莱莱爱打怪 稀土掘金技术社区 2023-12-10 09:31 重庆 稀土掘金技术社区 掘金，一个帮助开发者成长的技术社区 740篇原创内容 前言：nginx作为当今火爆的、高性能的http及反向代理服务，不管前端还是后端，都需要全面去了解，学习，实"><link rel="shortcut icon" href="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/favicon.ico"><link rel="canonical" href="http://example.com/2024/05/17/nginx/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 晨空","link":"链接: ","source":"来源: 晨空","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '晨空',
  title: 'nginx-一篇通',
  postAI: '',
  pageFillDescription: 'nginx 一把梭！（超详细讲解+实操）, 前言：, 1、nginx 介绍, 1.1、nginx 特点, 1.2、nginx 架构, 1.3、nginx模块, 1.4、nginx常见应用场景, 2、nginx安装, 3、nginx目录一览, 4、nginx.conf文件 解读, 5、localtion 路由匹配规则, 5.1、前缀匹配（无修饰符）, 5.2、精确匹配（ x3D ）, 5.3、前缀匹配（ ^~ ）, 5.4、正则匹配（~ 区分大小写）, 5.5、正则匹配（~* 不区分大小写）, 5.6、通用匹配（ x2F ）, 5.7、关于location 匹配优先级, 6、反向代理, 6.1、服务准备, 6.2、修改nginx.conf文件, 6.3、测试反向代理, 6.4、反向代理流程与原理, 7、负载均衡, 7.1、准备3个不同端口的springboot服务, 7.2、nginx常用的负载策略, 7.2.1、轮询, 7.2.2、weight, 7.2.3、ip_hash, 7.2.4、least_conn, 8、动静分离, 8.1、准备工作, 8.2、修改nginx.conf文件, 8.3、演示, 9、跨域, 9.1、为何会产生跨域？, 9.2、跨域演示, 9.3、nginx解决跨域, 10、缓存, 10.1、nginx缓存配置参数表格一览, 10.2、nginx缓存使用与效果演示, 11、黑白名单, 11.1、语法作用域, 11.2、黑白名单演示, 12、nginx限流, 12.1、nginx限流配置解释, 12.2、nginx限流（针对请求速率）, 12.2.1、限制每秒同一ip最多访问5次x2F1s, 12.2.2、打开burst参数并设置成5, 12.2.3、打开nodelay, 12.3、nginx限流（针对连接数量）, 13、https配置, 13.1、https_ssl模块安装, 13.2、域名购买amp解析ampssl证书申请与验证, 13.3、上传并配置nginx以及演示, 13.4、http跳转https, 14、压缩, 14.1、压缩前, 14.2、压缩后, 15、其他一些比较常用的指令与说明, 15.1、rewrite, 15.2、if, 15.3、nginx全局变量, 15.4、auto_index, 15.5、rootampalias, 15.5.1、root, 15.5.2、alias, 15.5.3、proxy_pass 中的斜线与root和 alias的相似之处, 15.6、upstream 中常用的几个指令, 16、重试策略, 16.1、服务不可用重试, 16.2、错误重试, 16.3、关于backup, 17、最后, 17.1、贴出完整nginx.conf文件一把梭超详细讲解实操原创蝎子莱莱爱打怪稀土掘金技术社区重庆稀土掘金技术社区掘金一个帮助开发者成长的技术社区篇原创内容前言作为当今火爆的高性能的及反向代理服务不管前端还是后端都需要全面去了解学习实操一句话搞懂如何使用以及工作逻辑对于程序员来说是必不可少的我们看看本文的大纲先了解一下本文都讲了哪些东西大纲如下介绍安装目录一览文件解读路由匹配规则反向代理负载均衡动静分离跨域缓存黑白名单限流配置压缩其他一些常用指令与说明重试策略最后总结一些说明系统本文使用版本关于如何安装本文不再赘述参考之前我的一篇文章中安装在学习前最好需要知道或者了解事件驱动思想以及几种常见多路复用模型和模式这样你才能从底层更深刻的理解的架构设计介绍为了有一个全面的认知接下来我们先来看看的架构以及一些特点特点处理响应请求快异步非阻塞零拷贝缓存机制扩展性好模块化设计内存消耗低异步非阻塞多阶段处理具有很高的可靠性无数次的生产验证很多头部公司都在用热部署高并发连接事件驱动模型多进程机制自由的许可协议可以自己修改代码后发布包容性极强架构从上边这张图我们可以一览的架构设计首先我们可以直观得出的几大特点事件驱动异步非阻塞本质来说事件驱动是一种思想事实上它不仅仅局限于编程事件驱动思想是实现异步非阻塞特性的一个重要手段对于服务器来说造成性能拉胯不支持高并发的常见原因就是由于使用了传统的模型造成在内核没有可读可写事件或者说没有数据可供用户进程读写时用户线程一直在等待其他事情啥也干不了就是干等等待内核上的数据可读可写这样的话其实是一个线程线程在系统也是进程对应一个请求请求是无限的而线程是有限的从而也就形成了并发瓶颈而大佬们为了解决此类问题运用了事件驱动思想来对传统模型做个改造即在客户端发起请求后用户线程不再阻塞等待内核数据就绪而是立即返回可以去执行其他业务逻辑或者继续处理其他请求当内核的操作完成后内核系统会向用户线程发送一个事件通知用户线程才来处理这个读写操作之后拿到数据再做些其他业务后响应给客户端从而完成一次客户端请求的处理事件驱动的模型中程序不必阻塞等待操作的完成也无需为每个请求创建一个线程从而提高了系统的并发处理能力和响应速度事件驱动型的模型通常也被被称为多路复用即这种模型可以在一个线程中处理多个连接复用就是指多个连接复用一个线程多路也即所谓的多个连接通过这种方式避免了线程间切换的开销同时也使得用户线程不再被阻塞提高了系统的性能和可靠性支持事件驱动是因为他利用了操作系统提供的多路复用接口如系统中常用的多路复用接口有这些接口可以监视多个文件描述符的状态变化当文件描述符可读或可写时就会向用户线程发送一个事件通知用户线程通过事件处理机制读取写入数据来处理这个事件之后进行对应的业务逻辑完了进行响应简单一句话概括事件驱动机制就是指当有读写连接事件就绪时再去做读写接受连接这些事情而不是一直在那里傻傻的等也正应了他的名词事件驱动基于事件驱动思想设计的多路复用如相对于传统模型达到了异步非阻塞的效果既然提到了那么我们就简单说一下注意我这里是简单描述后续有时间会对相关知识点从源码层面做个系统的整理和图解将已连接的都放到一个文件描述符集合然后用户态调用函数将文件描述符集合拷贝到内核里让内核来检查是否有网络事件产生检查的方式很粗暴就是通过遍历文件描述符集合的方式当检查到有事件产生后将此标记为可读或可写接着再把整个文件描述符集合拷贝回用户态里然后用户态还需要再通过遍历的方法找到可读或可写的然后再对其处理函数的话其实和大差不差唯一区别可能就是列表的结构有所不同不再受的限制这里就不多说了在前边两者的基础上做了很大的优化都需要遍历整个列表当检测到传入的可读可写时则列表给用户空间用户态仍然需要遍历因为内核给用户态的是整个列表而则是通过红黑树结构将需要监控的插入到进去然后当有可读时会通过回调机制来将其添加到可读列表中然后内核将可读列表给用户态即可据说此处使用了这里我们不去验证探究后续写相关文章时在深究吧整个过程少了无效的遍历以及不用整个集合多进程机制另外可以得知有两种类型的进程一种是主进程一种是工作进程主进程主要负责项工作加载配置启动工作进程及非停升级另外进程是主进程启动后而来的假设了多个具体在于你的配置进程并且在进程中通过套接字监听端口然后每个进程都可以去这个监听的当一个连接进来后所有进程都会收到消息但是只有一个进程可以这个连接其它的则失败保证只有一个去的方式就是加锁有了锁之后在同一时刻就只会有一个进程去连接在进程拿到请求后就开始按照进程内的预置模块去处理该请求最后返回响应结果并断开连接其实如果熟悉模型你会发现的设计有的影子只不过的主是会负责的而的主进程对应主是不会去的而是交给了进程来处理进程除了连接之外还会执行网络读写存储读写内容传输以及请求分发等等而其代码的模块化设计也使得我们可以根据需要对功能模块进行适当的选择和修改编译成符合特定需要业务的服务器服务端缓存主要实现服务器对客户端数据请求的快速响应服务器在接收到被代理服务器的响应数据之后一方面将数据传递给客户端另一方面根据的配置将这些数据缓存到本地硬盘上当客户端再次访问相同的数据时服务器直接从硬盘检索到相应的数据返回给用户从而减少与被代理服务器交互的时间在缓存数据时运用了零拷贝以及技术使得数据性能大幅提升反向代理的强大之处其中一个就是他的反向代理通过反向代理可以隐藏真正的服务增加其安全性同时便于统一管理处理请求另外可以很容易的做个负载均衡更好的面对高并发的场景模块服务器由多个模块组成每个模块就是一个功能某个模块只负责自身的功能所以说对于高内聚低耦合的编程规则在身上可谓体现的淋漓尽致模块示意图如下核心模块是服务器正常运行必不可少的模块提供错误日志记录配置文件解析事件驱动机制进程管理等核心功能标准模块提供协议解析相关的功能如端口配置网页编码设置响应头设置等可选模块主要用于扩展标准的功能让能处理一些特殊的服务如多媒体传输解析请求支持等邮件服务模块主要用于支持的邮件服务包括对协议协议和协议的支持第三方模块是为了扩展服务器应用完成开发者自定义功能如支持支持等常见应用场景常用场景挺多的比如反向代理负载均衡缓存限流黑白名单静态资源服务动静分离防盗链跨域高可用其中我认为最最基础的也是应用最多的就是反向代理这里我们画个图简单看下什么是反向代理其他的那些使用场景我们先不做展开放到下边一个个哔哔所谓反向代理其实很好理解就是代理的服务端与之对应的正向代理一般代理的是客户端反向代理如下示意好了介绍了这么多想必到这里应该对有个大体的了解了吧接下来我们安装并一个一个的分析介绍的知识点安装关于的安装在这里不再赘述参考我之前的一篇文章中安装目录一览我们使用命令查看一下的目录对其结构有个初步的认识存放一系列配置文件的目录程序相关配置文件程序相关配置文件备份程序参数文件程序参数文件备份编码映射文件编码映射文件媒体类型控制文件媒体类型控制文件备份主配置文件主配置文件备份程序相关配置文件程序相关配置文件备份程序相关配置文件程序相关配置文件备份编码映射文件存放网页文档错误页码显示网页文件网页的首页文件存放的日志文件我把压缩包下载到目录了不用管这个存放启动程序启动程序我自己建的目录不用管这个从输出可以看到分的很清晰有配置目录目录目录启动程序目录关于目录的一点小说明上边的仅仅是的主目录事实上生效的主配置文件一定是这不一定而是取决于你启动时候有没有指定实际使用中我发现我机器上有好几个地方都存在文件使用看一下如下图所示图片那如何确定当前生效的是哪个呢很简单使用命令即可查看当前生效的如下可以看到我当前生效的是这个文件我是使用的命令启动的未指定用哪个文件启动所以可以看出默认使用的是这个配置文件另外还有一个就是的日志我发现我的日志就不是在这个目录下而是放到了这个目录下了文件的存放和我的文件中的配置有关系如下演示好了在了解了整体的目录结构后就来看看这个文件这个文件是的核心配置想玩转读懂这个配置文件是必不可少的一项基本功文件解读首先我们要知道文件是由一个一个的指令块组成的用标识一个指令块指令块中再设置具体的指令注意指令必须以号结尾指令块有全局块块块块和块以及块精简后的结构如下全局模块模块模块模块模块块块模块块块各模块的功能作用如下描述全局模块配置影响全局的指令比如运行的用户名进程存放路径日志存放路径配置文件引入进程数等块配置影响服务器或与用户的网络连接比如每个进程的最大连接数选取哪种事件驱动模型或者是其他等等支持的来处理连接请求是否允许同时接受多个网路连接开启多个网络连接序列化等块可以嵌套多个配置代理缓存日志格式定义等绝大多数功能和第三方模块的配置如文件引入定义日志自定义是否使用传输文件连接超时时间单连接请求数等块配置虚拟主机的相关参数比如域名端口等等一个中可以有多个块配置路由规则块配置上游服务器的地址以及负载均衡策略和重试策略等等下面看下长啥样并对一些指令做个解释注意有些指令是可以在不同指令块使用的需要时可以去官网看看对应指令的作用域我这里只是演示这里我以文件为例指定进程运行用户以及用户组默认由账号运行指定工作进程的个数默认是个具体可以根据服务器数量进行设置比如有个可以设置为如果不知道的数量可以设置为会自动判断服务器的个数并设置相应的进程数用来定义全局错误日志文件输出路径这个设置也可以放入块块日志输出级别有可供选择其中输出日志最为最详细而输出日志最少指定日志位置和日志级别用来指定进程的存储文件位置设置网路连接序列化防止惊群现象发生默认为支持的工作模式有和其中和都是标准的工作模式和是高效的工作模式不同的是用在平台上而用在系统中对于系统工作模式是首选用于定义每个工作进程的最大连接数默认是最大客户端连接数由和决定即在作为反向代理时变为进程的最大连接数受系统进程的最大打开文件数限制在执行操作系统命令后的设置才能生效对服务器相关属性的配置如下引入文件类型映射文件如果没有找到指定的文件类型映射使用默认配置设置日志打印格式设置日志输出路径以及日志级别开启零拷贝省去了内核到用户态的两次故在文件传输时性能会有很大提升数据包会累计到一定大小之后才会发送减小了额外开销提高网络效率设置服务器与客户端会话的超时时间超过这个时间之后服务器会关闭该连接客户端再次发起请求则需要再次进行三次握手开启压缩功能减少文件传输大小节省带宽每个进程每次调用传输数量不能大于设定的值默认为即不设上限配置你的上游服务即被代理的后端服务的和端口域名备机服务器监听的端口监听的地址服务器域名多个使用英文逗号分割设置日志输出路径以及级别会覆盖指令块的配置用于定义请求匹配规则以下是实际使用中常见的中配置即分为首页静态动态三种第一种直接匹配网站根目录通过域名访问网站首页比较频繁使用这个会加速处理一般这个规则配成网站首页假设此时我们的网站首页文件就是静态资源文件的根目录比如我的是静态资源文件名称比如网站首页文件第二种静态资源匹配静态文件修改少访问频繁可以直接放到或者统一放到文件服务器减少后端服务的压力假设把静态文件我们这里放到了目录下访问后将会去获取文件并响应第二种的另外一种方式拦截所有后缀名是这些类静态的的请求让他们都去直接访问静态文件目录即可第三种用来拦截非首页非静态资源的动态数据请求并转发到后端应用服务器请求转向是指令块所定义的服务器列表拒绝的黑名单允许的白名单定义错误返回的页面凡是状态码是总之开头的都会返回这个根目录下文件夹下的文件内容其余的配置如果有需要的话一般我们实际使用中有很多配置通常的做法并不是将其直接写到文件而是写到新文件然后使用指令将其引入到即可这样使得主配置文件更加清晰以上就是文件的配置了主要讲了一些指令的含义当然实际的指令有很多我在配置文件并没有全部写出来准备放到后边章节详细阐述这些东西比如匹配规则反向代理动静分离负载均衡策略重试策略压缩限流缓存跨域这些我们都没细说这些东西比较多比较细不可能把使用规则和细节都写到上边的配置文件中所以我们下边一一解释说明关于这些东西的配置和使用方式另外值的注意的是因为有些指令是可以在不同作用域使用的如果在多个作用域都有相同指令的使用那么将会遵循就近原则或者我愿称之为内层配置优先你在配了日志级别也在某个中配了日志级别那么这个将使用他自己配置的已不使用外层的日志配置路由匹配规则什么是根据用户请求的来匹配对应的模块匹配到哪个请求将被哪个块中的配置项所处理配置语法修饰符常见匹配规则如下修饰符作用空无修饰符的前缀匹配匹配前缀是你配置的比如说你配的是的精确匹配正则表达式模式匹配区分大小写正则表达式模式匹配不区分大小写类型的前缀匹配类似于无修饰符前缀匹配不同的是如果匹配到了那么就停止后续匹配通用匹配任何请求都会匹配到只要你域名对所有请求通吃前缀匹配无修饰符首先我提前创建了文件之后改一下文件给前缀是的请求返回这个文件如下然后在宿主机中配置域名映射后观察到服务器返回内容如下可以看到域名和域名返回了原因在于映射的是个目录而不是个文件所以提示我们这个我们不用管没关系总之我们知道域名域名和域名这三个通过我们配置的无修饰符前缀匹配规则都能匹配上就行了为了方便我们下边的几个规则演示不再跳转静态文件了而是直接一句话精确匹配为了演示精确匹配我们再给文件增加一个配置如下标红处实际效果如下可以看出来精确匹配就是精确匹配差一个字也不行前缀匹配我们上边说了不带任何修饰符的前缀匹配小节这里我们看下修饰符是的前缀匹配和不带修饰符的前缀匹配有啥区别先在文件增加个并配好如下图片效果如下图片可以看到带修饰符的前缀匹配像域名和域名是可以匹配上的而不带修饰符的前缀匹配这两个类型的是匹配不上的直接返回了其他的和不带修饰符的前缀匹配似乎都差不多正则匹配区分大小写正则表达式的匹配需要你对正则语法比较熟悉熟悉语法后写匹配规则也就得心应手了添加个并配置如下表示开头表示结尾图片实际效果如下图片可以看到修饰的正则是区分大小写的接下来我们看下不区分大小写的匹配正则匹配不区分大小写改下在修饰符后加个看下实际效果可以看到这次是可以匹配上的说明确实是不区分大小写的通用匹配通用匹配使用一个表示可以匹配所有请求一般配置文件最后都会有一个通用匹配规则当其他匹配规则均失效时请求会被路由给通用匹配规则处理如果没有配置通用匹配并且其他所有匹配规则均失效时会返回错误图片通用匹配实际效果可以看到通用匹配很好理解只要你域名写对了那么所有的都会被匹配上来者不拒的感觉关于匹配优先级上边我们说了种匹配规则那么如果存在多个到底走哪个呢这就的说说的匹配优先级了先来看下官网和上的资料如下图片综上资料我们对匹配优先级的总结如下优先走精确匹配精确匹配命中时直接走对应的停止之后的匹配动作无修饰符类型的前缀匹配和类型的前缀匹配命中时收集命中的匹配对比出最长的那一条并存起来最长指的是与请求匹配度最高的那个如果步骤中最长的那一条匹配是类型的前缀匹配直接走此条匹配对应的并停止后续匹配动作如果步骤最长的那一条匹配不是类型的前缀匹配也就是无修饰符的前缀匹配则继续往下匹配按的声明顺序执行正则匹配当找到第一个命中的正则时停止后续匹配都没匹配到走通用匹配如果有配置的话如果没配置通用匹配的话上边也都没匹配上到这里就是了如果非要给修饰符排个序的话就是酱样子正则无修饰符的前缀匹配关于就到这里是一个很重要的点学好这个才知道到底是咋匹配的反向代理反向代理示意图我们上边说过这里再次粘一下接下来我们开始用一个小来演示反向代理的使用服务准备首先将我本地的一个服务打成胖图片然后使用方式启动服务且指定端口为最后使用测试接口是否正常注意此时还没被代理而是直接调的服务启动服务并验证接口无误后接下来我们修改配置文件让反向代理我们的服务修改文件要让代理我们的服务很简单简单描述一下就是两步通过指令块来定义我们的上游服务即被代理的服务通过指令块中的指令指定该要路由到哪个配置好和后如果来了请求后会通过路由到对应的然后会将请求打到定义的服务地址中去下边我们看看使用命令修改文件如下注意上边的后边这个斜线加和不加区别挺大的加的话不会拼接而不加的话会拼接这一点我们在小节会讲到这里留意下就好测试反向代理修改完后我们执行命令重新加载配置然后再中调用一下如下在第一次调用中出现了一个错误图片解决办法很简单在虚拟机执行命令来关闭的限制即可或者参考上的解决方案解决后再次调用发现可以了注意是我随便写的域名没做解析我是在请求发出方宿主机配了所以才能请求通同时也可使用命令观察到日志输出如下反向代理流程与原理对于上边演示的反向代理案例的流程与原理我们来个示意图如下这个图比较重要接下来我们演示下负载均衡负载均衡说到负载均衡很多人应该并不陌生总而言之负载均衡就是避免高并发高流量时请求都聚集到某一个服务或者某几个服务上而是让其均匀分配或者能者多劳从而减少高并发带来的系统压力从而让服务更稳定对于来说负载均衡就是从模块定义的后端服务器列表中按照配置的负载策略选取一台服务器接受用户的请求准备个不同端口的服务想要演示负载均衡我们首先得多搞几个服务搞一个服务是没法儿演示的所以我启动了个不同端口的服务如下使用对进行分屏最左侧是端口中间是右侧是接下来我们说一下负载策略再开始常用的负载策略负载策略描述特点轮询默认方式每个请求会按时间顺序逐一分配到不同的后端服务器在轮询中如果服务器掉了会自动剔除该服务器缺省配置就是轮询策略此策略适合服务器配置相当无状态且短平快的服务使用权重方式在轮询策略的基础上指定轮询的几率权重越高分配到的请求越多此策略可以与和结合使用此策略比较适合服务器的硬件配置差别比较大的情况依据的值来分配在版本之前不能在中使用权重不能与同时使用此策略适合有状态服务比如当有服务器需要剔除必须手动掉最少连接方式此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况第三方响应时间方式根据后端服务器的响应时间来分配请求响应时间短的优先分配本身不支持如果需要这种调度算法则必须安装模块第三方依据分配方式按访问的的哈希结果来分配请求使每个定向到一台后端服务器本身不支持如果需要这种调度算法则必须安装的软件包轮询轮询策略是默认的所以只需要如下这样修改配置文件就可以了重启后观察一下以上图片可以看到是按中的先后顺序来进行轮询的指令用于指定轮询机率的默认值为的数值与访问比率成正比接下来我们指定端口的服务的如下看下权重策略下的请求结果可以看到在一轮轮询中命中次由于配置了所以命中了次命中了次即配置了的服务命中几率是或者的两倍设定哈希很简单就是在你的中指定即可如下图片重启后看下效果图片可以看到由于我的访问总是固定的宿主机的根据算法我的被匹配给了端口的服务所以只要我不换不管我请求多少次请求都是被转发到了的服务上了同一样设定最小连接数策略也很简单就是在你的中指定即可如下图片由于我这里最小连接数看不出啥效果所以就不演示截图了知道怎么配置最小连接数即可关于第三方的负载策略不做过多说明了可以看看官方文档获取其他的网上资料动静分离在说动静分离前我们要知道为何要做动静分离以及他能解决啥问题首先我们常见的系统中会有大量的静态资源文件比如掘金主页面刷新后的如下图片可以看到有很多静态资源如果将这些资源都搞到后端服务的话将会提高后端服务的压力且占用带宽增加了系统负载要知道静态资源的访问频率其实蛮高的所以为了避免该类问题我们可以把不常修改的静态资源文件放到的静态资源目录中去这样在访问静态资源时直接读取服务器本地文件目录之后返回这样就大大减少了后端服务的压力同时也加快了静态资源的访问速度何为静何为动呢静将不常修改且访问频繁的静态文件放到本地静态目录当然也可以搞个静态资源服务器专门存放所有静态文件动将变动频繁实时性较高的比如后端接口实时转发到对应的后台服务接下来我们将构造一个页面然后点击按钮后发送请求到后端接口流程如下准备工作首先我们搞个请原谅我这粗糙的前端代码内容如下之后使用命令将文件上传到虚拟机修改文件首先我们配置俩规则一个是读取静态文件一个是转发到我们配置的服务中去如下图片演示首先我们在浏览器输入可以看到请求返回了一个页面其实就是我们刚才的文件图片接着我们输入要查询的人名之后点击调用接口按钮如下图片返回数据图片查看访问日志可以看到两次请求的输出图片到这里动静分离就演示完了接下来我们看下跨域跨域为何会产生跨域产生跨域问题的主要原因就在于同源策略为了保证用户信息安全防止恶意网站窃取数据同源策略是必须的该政策由公司于年引入浏览器目前所有浏览器都实行这个政策同源策略主要是指三点相同即协议域名端口相同的两个请求则可以被看做是同源的但如果其中任意一点存在不同则代表是两个不同源的请求同源策略会限制不同源之间的资源交互从而减少数据安全问题跨域演示首先我在文件中加一个配置也即将前后端配成不同的并且监听的端口以及域名名称都不一致从而造成访问前端服务和后端服务时候这俩服务不是同源如下之后我修改中的后端地址重启并配置宿主机的文件之后在浏览器中测试一下图片可以看到浏览器提示我们受同源规则影响我们不能跨域访问资源造成的原因是我的两个域名解析出来的端口不一致一个是一个是不符合同源策略所以必然会有跨域报错解决跨域首先想解决跨越就得避免不同源而我们可不可以把对后端的代理放在前端的中呢也就是说让前后端统一使用一个端口一个答案是可以的因为支持多个配置呀一个处理前端一个转发后端我们改下配置文件试一把如下之后重启后在浏览器输入效果如下上边请求返回了页面之后我们输入参数点击调用接口查看到后端接口的调用如下图片从上边可以看到我上边设想的方式是可行的当然有些资料上有说使用设置的方式解决跨域但是在实际测试中设置的方式始终没解决跨域试了好久也没解决掉有试过此方式解决的大佬帮忙看看我这是哪里配错了还是咋的在此提前感谢了图片缓存在开头我们就介绍过代理缓存可以在某些场景下有效的减少服务器压力让请求快速响应从而提升用户体验和服务性能那么缓存如何使用呢在使用及演示前我们先来熟悉下相关的配置以及其含义知道了这些才能更好的使用缓存缓存配置参数表格一览指令名称作用解释语法默认配置示例作用域设置是否开启对后端响应的缓存规定开启缓存并且缓存名称为配置什么状态码可以被缓存以及缓存时长没有默认值对于状态为和的缓存文件缓存时间是分钟设置缓存文件的使用请求的以及拼接成缓存指定缓存存储的路径文件名为的值然后多级目录的话根据参数来生成参数用来指定在共享内存中缓存数据的名称和内存大小比如用来指定缓存没有被访问后超时移除的时间默认是分钟也可以自己指定比如用来指定缓存的最大值超过这个值则会自动移除最近最少使用淘汰算法的缓存这个指令对应的参数很多具体见官网无设置缓存存放的目录为并设置缓存名称为大小为三天未被访问过的缓存将自动清除磁盘中缓存的最大容量为定义不从缓存中获取响应数据的条件如果字符串参数中至少有一个值不为空且不等于则不会从缓存中获取响应没有默认值指定某一个相同请求在几次请求之后才缓存响应内容规定某一个请求在第次之后才走缓存指定后端服务器在返回什么状态码的情况下可以使用过期的缓存规定服务在出现以及时可使用过期缓存默认不开启开启后若出现并发重复请求只让一个请求去后端读数据其他的排队并尝试从缓存中读取开启缓存锁等待缓存锁超时之后将直接请求后端且结果不会被缓存等待缓存锁超时之后将直接请求后端结果不会被缓存如果客户端请求方法在该指令中则响应将被缓存和方法总是被添加到列表中尽管建议显式地指定它规定可缓存的方法有事实上模块中代理缓存相关的指令远不止这些在这里我不可能把所有都列出来只列出上边那几个已经很占篇幅了如果有需要请参考官方文档在官方文档中详细描述了模块包含了部分的各种指令作用以及使用方式相信在遇到困难和疑惑时官方文档永远是你最好的老师如下缓存使用与效果演示首先我们想要的效果是将参数一样的请求的结果缓存到接下来我们修改下文件如下指定缓存存放目录为并设置缓存名称为大小为天未被访问过的缓存将自动清除磁盘中缓存的最大容量为指定参数中只要有字母就不走缓存使用名为的缓存空间对于状态码的数据缓存分钟定义生成缓存键的规则请求的参数作为缓存资源至少被重复访问次后再加入缓存出现重复请求时只让其中一个去后端读数据其他的从缓存中读取上面的锁超时时间为超过未获取数据其他请求直接去后端对于请求参数中有字母的不走缓存判断该变量是否有值如果有值则不进行缓存没有值则进行缓存在响应头中添加一个缓存是否命中的状态便于调试图片在上边配置文件中除了缓存相关的配置我们还加了一个参数这个参数可以方便从响应头看到是否命中了缓存方便我们观察其不同的值有不同的含义的值集合如下请求未命中缓存请求命中缓存请求命中缓存但缓存已过期请求命中了陈旧缓存验证陈旧缓存依然有效命中的缓存内容陈旧但正在更新缓存响应结果是从原始服务器获取的文件配好后在请求之前先看下数据库和张无忌都是存在的如下图片接下来我们分别查询张无忌和来看看缓存命中情况查询张无忌第一次未命中因为此参数之前没请求过缓存中确实没有图片第二次也未命中就不截图了第三次未命中图片第四次命中图片查询第一次未命中图片第次也都是即未命中截图略第四次仍然是未命中说明我们在中配置的规则参数中带字母则不缓存生效了图片黑白名单黑白名单比较简单后配置你的白名单后配置你的黑名单在实际使用中我们一般都是建个黑名单和白名单的文件然后再中一下这样保持主配置文件整洁也好管理下边我为了方便就直接在主配置写了语法作用域关于黑白名单的语法和作用我们直接看下官网的示例可以看到可以是也可以是也可以按照网段来配置当然黑白配置可以在和这几个域都可以区别只是作用粒度大小问题当然建议我们使用这个库库支持按地区国家进行屏蔽并且提供了库当需要配置的名单比较多或者根据地区国家屏蔽时这个库可以帮上大忙下面我们配置并演示一下黑白名单演示允许任何访问前端然后禁止访问后端文件如下访问前端走这个可以访问成功图片访问后端走这个显示被禁止了图片限流主要有两种限流方式按并发连接数限流按请求速率限流使用的令牌桶算法关于模块里边有很多种限流指令官网资料一览图片我们下面使用模块中的和这两个指令来达到限制单个的请求速率的目的限流配置解释在中添加限流配置如下对请求速率限流对上图标红的配置做个解释表示基于客户端来做限流表示使用来作为内存区域存储访问信息的名字大小为能存储地址的访问信息可以存储地址访问信息表示相同每秒最多请求次是精确到毫秒的也就是说此配置代表每毫秒处理一个请求这意味着自上一个请求处理完后若后续毫秒内又有请求到达将拒绝处理该请求如果没配的话英文爆发的意思意思是设置一个大小为的缓冲队列若同时有个请求到达会处理第一个请求剩余个请求将放入队列然后每隔从队列中获取一个请求进行处理若请求数大于将拒绝处理多余的请求直接返回针对的是参数这个配置表示被放到缓冲队列的这个请求会立马处理不再是每隔取一个了但是值得注意的是即使这个突发请求立马处理并结束后续来了请求也不一定不会立马处理因为虽然请求被处理了但是请求所占的坑并不会被立即释放而是只能按一个来释放释放一个后才将等待的请求入队一个另外两个表示当被限流后的返回码代表日志级别注意如果不开启且开启了这个配置那么将会严重影响用户体验你想想假设队列长度为的话每处理一个那队列最后那个请求得等后才能被处理那不超时才怪呢此时已经意义不大了所以一般情况下建议和结合使用从而尽可能达到速率稳定但突然流量也能正常处理的效果限流针对请求速率为了突出和的作用我们一步一步演示限制每秒同一最多访问次修改把注释掉如下图片上边的配置意味着每秒最多处理次同样的请求我们使用设置个线程循环次间隔时间为效果如下成功失败图片如果我们将间隔时间改的话是都可以成功的因为一秒最多次精确到毫秒其实就是最多一次而一次正好没超过我们配置的的速率图片运行发现间隔访问一次的请求都成功了图片打开参数并设置成现在我们的速率不变还是最多次一秒但是设置代表缓冲队列的长度为每隔从缓冲队列拿一个进行处理配置如下之后我们配置线程数量为每隔掉一次效果如下可以看到共计个请求被处理第一个是被进程直接处理之后往塞了个每隔拿一个进行处理剩下的都被返回了状态码代表被拒绝了我们找一个这个被拒的看看状态码打开我们上边说过打开的话代表放到队列的请求直接处理不再按速率次拿了配置如下图片接下来我们还是配置个线程然后每个线程间隔请求一次看下效果图片可以很明显的看到开启后响应时间几秒明显比不开启快很多但是请求成功的还是个因为就像我们上边说的虽然会即时处理但是释放坑位是释放一个也就是说即时开启了但释放令牌的速度是不变的所以参数本质上并没有提高访问速率而仅仅是让处于队列的请求被快速处理罢了限流针对连接数量针对连接数量的限流和速率不一样即使你速率是一次只要你连接数量不超过设置的那么也访问成功如果连接数超过设置的值将会请求失败值得注意的是他是模块中的不要和速率限流的模块搞混了配置如下针对对请求连接数限流简单对以上标黄处说明一下代表的意思是基于连接数量限流限流的对象是名称是存储空间大小即存放某的访问记录标识该最大支持个连接超过则返回被限流后状态码默认是当然你也可以修改返回码像上边的针对请求速率限流返回码就是我修改的使用搞个线程延迟演示下效果可以看到由于我们配置的并发数是所以个连接中有个都被限了这个理解起来似乎比速率限流简单些我们就不过多解释了配置说到大家应该并不陌生我这里不啰嗦介绍了一般我们安装的模块都是不包含模块的所以需要手动安装下安装完之后我们再说如何配置模块安装首先我们使用大写看下有没有安装模块图片可以看到我已经安装了实际上我可以直接使用模块了但是为了文章完善性我下边说一下模块的安装步骤注意下边的模块是安装到我的旧版本去了而我当前生效运行的是使用命令可看出当前运行的图片下边的安装仅仅是为了内容全面而不是真正使用版本的或者版本的模块本文使用的版本都是是我之前的一个版本没有模块情况下首先我们进入解压目录我的是总之就是找到你的解压目录之后在该目录执行命令来安装模块如下图图片安装好后在目录中执行命令重新编译注意此处无需成功后我们执行命令将编译后的文件覆盖到之后执行可看到模块就安装成功了操作记录图如下图片域名购买解析证书申请与验证要配置最好是有个域名所以我花一杯酱香拿铁的买了一个域名在买域名前需要进行域名模板实名具体操作去腾讯云官网看这里不啰嗦了我买的域名是如果我没记错的话这是我的第一个域名虽然他块钱但是我很珍惜他接下来可以在我的域名中看到已经成功了图片有域名了下一步就需要配置解析让别人通过公网也访问到呀所以点击上图的解析按钮后来到下边的页面添加解析记录如下主机记录的结果是的结果是的意思为泛解析对应的结果是图片配置好解析后我们开始申请一个免费的证书并将其和我上边的域名绑定如下提交申请后因为我们选择的手动验证所以接下来按照人家的提示手动配置这个操作比较重要不做这一步证书验证肯定过不去所以必须做并且做对之后我们在我的证书看到已经完成验证此时就可以下载证书然后配置我们的了因为我们接下来要配置到反向代理服务器所以这里选择下载类型的证书图片上传并配置以及演示下载到本地后是个我们解压之后会看到里边有个文件分别是证书文件证书文件可忽略该文件私钥文件文件文件是申请证书时由您上传或系统在线生成的提供给机构安装时可忽略该文件之后我们仅需要把和这俩货上传到我新建的文件夹操作如下图片上传完成图片证书准备好后我们需要配置一个的如下配置下边的指令名称都有注释说明了各个指令是干啥的我也就不啰嗦了配置默认访问端口号为填写绑定证书的域名请填写证书文件的相对路径或绝对路径请填写私钥文件的相对路径或绝对路径停止通信时加密会话的有效期在该时间段内不需要重新交换密钥服务器支持的版本请按照以下套件配置配置加密套件写法遵循标准开启由服务器决定采用的密码套件可以看到我们上传到目录下的和文件被使用到了现在我们仅仅是配好一个类型的光一个没法访问也没意思我们需要让给他配置上游服务以及路由规则这里我们直接使用我们上边的端口那个中的配置直接过来的配置如下到这里就可以通过方式访问我们的页面和接口了但是需要注意的是由于我们的协议和域名换了所以里边的接口地址也得变了如下之后我们将上传到的目录并重启之后在浏览器访问试试注意我最开始在配置解析时记录值配的是公网但是我发现好像不好使总是连接失败图片后来改成局域网发现可行了图片修改云解析记录值为后访问效果如下图片图片从上边可以看到我们可以通过方式访问前端页面和后台接口了跳转一般情况下为了安全都不使用方式访问页面后台服务但是有的人就是喜欢使用访问怎么办好说我给加个跳转你访问我给你跳转到想达到此效果需要先修改下文件重定向到目标地址之后重启看下演示效果首先请求会返回重定向地址让你重新定向到图片请求这一步浏览器会自动发起请求无需手动点击或刷新啥的定向后的目标地址图片可以看到方式的请求被成功重定向到了端口对应的压缩压缩功能比较实用尤其是处理一些大文件时而是规定的三种标准压缩格式之一目前绝大多数的网站都在使用传输等资源文件需要知道的是并不是每个浏览器都支持压缩如何知道客户端浏览器是否支持压缩呢可以通过观察某请求头中的来观察是否支持压缩另外只有客户端支持也不顶事服务端得返回格式的文件呀那么这件事可以帮我们做我们可以通过的配置来让服务端支持服务端返回压缩文件后浏览器进行解压缩从而展示正常内容压缩前首先应该明确的是我当前是没开启压缩的图片其次为了方便看出效果我们先将之前那个文件加点图片加点文字给他的文件大小弄大点如下图片这里无需重启看下没开启压缩时候的效果图片图片压缩后想要压缩就得配置我们修改文件在指令块添加如下内容开启关闭压缩机制根据文件类型选择是否开启压缩机制设置压缩级别一共个级别越高资源消耗越大越耗时但压缩效果越好设置是否携带的响应头处理压缩请求的缓冲区数量和大小对于不支持压缩功能的客户端请求不开启压缩机制比如低版本的浏览器不支持压缩设置压缩功能所支持的最低版本设置触发压缩的最小阈值根据不同配置对后端服务器的响应结果进行压缩几个指令的作用在注释中写明了这里不再过多解释接下来我们重启然后看下压缩前后的效果文件压缩图片接口响应压缩图片可以看到不管是还是接口响应数据压缩后的体积变得非常小了压缩的效果还是不错的但是值得注意的是压缩后虽然体积变小了但是响应的时间会变长因为压缩解压也需要时间呀压缩功能似乎有点用时间换空间的感觉当然压缩级别可以调的你可以选择较低级别的压缩这样既能实现压缩功能使得数据包体积降下来同时压缩时间也会缩短是比较折中的一种方案我在演示时为了效果配置的压缩级别是一共个级别是最高级别的压缩等级其他一些比较常用的指令与说明关于的指令其实太多了有些常用的指令不说一下的话有时候遇见了不懂啥意思所以这里说一下几个比较常用的指令上边文件解读以及某些小节中已经说了很多指令了这里也不管重不重复吧说明几个我觉得有必要讲的几个指令是通过正则表达式来改变可以同时存在一个或多个指令需要按照顺序依次对进行匹配和处理常用于重定向功能语法如下语法正则表达式要替换的内容默认作用域其中有如下几个值本条规则匹配完成后继续向下匹配新的规则本条规则匹配完成即终止不再匹配后面的任何规则返回临时重定向浏览器地址会显示跳转新的地址返回永久重定向浏览器地址会显示跳转新的地址下边我们演示下四种重写的效果首先修改文件临时重定向配置永久重定向配置配置图片配置可以看到我们定义访问的请求被替换为之后再被替换为最后找到这个文件并返回配置当访问这个请求会临时重定向到百度页面配置当访问这个请求会永久重定向到百度页面效果如下图片该指令用于条件判断并且根据条件判断结果来选择不同的配置其作用于为块这个指令比较简单因为编程中语句都是非常高频使用的但是里边怎么写就得说说的全局变量了因为我们很多时候都是在对比如参数域名等等做比对或者判断一般都使用正则的方式而这些都在全局变量中可以拿到比如下边这个判断就用到了全局变量指定参数中只要有字母就不走缓存正则表达式就不多说了具体使用时查一下我们下边列一下的全局变量全局变量变量解释本地时间时间格式请求中的的参数名即后面的形式的与相同等于当中的参数请求时如与相同这个变量指当前的请求不包括任何参数见包含请求参数的原始不包含主机名如如果包含参数则为否则为空字符串与相同等于当中的参数请求时如当前请求的不包含任何参数获取客户端客户端二进制客户端用于基本验证的用户名请求主机头字段否则为服务器名称如指令设置的后端服务器的域名或者地址指令设置的后端服务器的监听端口是和两个变量的结合用户请求信息如请求所用时间单位毫秒请求的方法比如等当前请求的文件的路径名由或和组合而成如请求的响应状态码如响应时送出的字节数数量即使连接中断这个数据也是精确的如传输给客户端的字节数响应头不计算在内这个变量和的模块中的参数保持兼容等于请求行的的值等于请求行的的值引用地址客户端信息如这个可以用来区分手机端还是端针对当前请求的根路径设置值主机名称客户端信息变量的值这个变量可以限制连接速率表示不限速记录过来的数据信息客户端请求主体信息的临时文件名方法如如果请求结束设置为当请求未结束或如果该请求不是请求链串的最后一个时为空如请求使用的协议通常是或如服务器地址在完成一次系统调用后可以确定这个值响应请求的服务器名称请求到达服务器的端口号如连接序列号当前通过连接发出的请求数版本工作进程的如果请求来自管道通信值为否则为获取代理访问服务器的客户端地址如果是直接访问该值为空字符串对应于当前请求的根目录或别名值的绝对路径名所有符号连接都解析为真实路径可以看到全局变量比较多但是没关系在使用时再去详查就好了一般用于快速搭建静态资源网站比如我要给自己搞个书籍网站里边放些好书以便需要时查看阅读首先建一个文件夹并往里放几本书图片之后我们配置使得访问时返回目录下的书籍配置如下打开可选参数有以的方式进行格式化可选参数有修改为会以显示文件大小默认为以显示出件的确切显示件时间格式图片重启并在浏览器输入注意后边的斜线不能去掉否则了具体原因我们下边马上会说看下效果图片和这俩货一般都是用于指定静态资源目录但是还是有挺大区别的虽然这是个小知识点但是如果你不清楚规则很容易走弯路所以这里阐明并演示这俩的区别说先说语法默认值作用域为请求设置根目录例如使用以下配置此时当你请求时文件将被作为响应内容响应给客户端也就是说指令会将拼接到后边即完整目录路径为演示效果如下图片中文意思别名这个和最大区别就是不会进行拼接下边我们改下文件来演示下注意一般的都不带后边的使用时这里的目录最后边一定要加否则就上边配置的意思就是当前你访问时会去配置的路径目录下找这个文件从而返回比如我现在的目录下没有文件则返回如下之后我们文件到目录然后看下效果可以看到成功返回了中的斜线与和的相似之处在我们上边的负载均衡以及动静锋利等等演示中可以看到我们的的配置基本上都是这么配的这里有个东西和与的规则很像所以我们在这里也提一下就是后边这个斜线如果你不写则会将的拼接到路径后边如果你写了则不会下边我们演示下这样更直观些修改如下这个不会拼接到后边如下这个会拼接到后边从而导致接口如下看出来了吗值后边加斜线和不加斜线区别是很大的不加斜线有点像会拼接加了斜线有点像不会进行拼接要牢记这个事情中常用的几个指令在中有些指令也是比较常用的所以我们这里也列一下参数描述反向服务地址权重与结合使用设置在参数设置的时间内最大失败次数如果在这个时间内所有针对该服务器的请求都失败了那么认为该服务器会被认为是停机了允许最大连接数服务器会被认为停机的时间长度默认为标记该服务器为备用服务器当主服务器停止时请求会被发送到它这里标记服务器永久停机了当节点恢复不立即加入重试策略服务不可用重试关于重试策略我们这里也说一下重试是在发生错误时的一种不可缺少的手段这样当某一个或者某几个服务宕机时因为我们现在大多都是多实例部署如果有正常服务那么将请求重试到正常服务的机器上去下边我们先修改下文件秒内如果请求端口这个应用失败次则认为该应用宕机时间到后再有请求进来继续尝试连接宕机应用且仅尝试次如果还是失败则继续等待秒以此循环直到恢复图片错误重试错误重试是你可以配置哪些状态下才会执行重试比如如下这个配置指定哪些错误状态才执行重试比如下边的超时接下来我们使用启动端口然后打个断点让这个服务超时验证下超时重试效果如下图片可以看到因为超时重试给然后也不可用重试给最终返回数据关于支持设置备用节点当所有线上节点都异常时会启用备用节点同时备用节点也会影响到失败重试的逻辑我们可以通过指令来定义备用服务器有如下特征正常情况下请求不会转到到服务器包括失败重试的场景当所有正常节点全部不可用时服务器生效开始处理请求一旦有正常节点恢复就使用已经恢复的正常节点服务器生效期间不会存在所有正常节点一次性恢复的逻辑如果全部服务器也异常则会将所有节点一次性恢复加入存活列表如果全部节点包括都异常了则返回错误接着我们修改下文件演示下的作用秒内如果请求某一个应用失败次则认为该应用宕机时间到后再有请求进来继续尝试连接宕机应用且仅尝试次如果还是失败则继续等待秒以此循环直到恢复设置位备机图片之后我们启动三个服务然后先停掉再停掉看看效果图片可以看到即使不可用也只是去重试而不会到备机重试如果都不可用则请求重试到备机最后为了方便粘贴以及观察这里贴出我机器上完整的文件如下贴出完整文件秒内如果请求某一个应用失败次则认为该应用宕机时间到后再有请求进来继续尝试连接宕机应用且仅尝试次如果还是失败则继续等待秒以此循环直到恢复设置位备机开启关闭压缩机制根据文件类型选择是否开启压缩机制设置压缩级别越高资源消耗越大越耗时但压缩效果越好设置是否携带的响应头处理压缩请求的缓冲区数量和大小对于不支持压缩功能的客户端请求不开启压缩机制比如低版本的浏览器不支持压缩设置压缩功能所支持的最低版本设置触发压缩的最小阈值根据不同配置对后端服务器的响应结果进行压缩指定缓存存放目录为并设置缓存名称为大小为天未被访问过的缓存将自动清除磁盘中缓存的最大容量为对请求速率限流对请求连接数限流演示配置注意一般的都不带后边的使用时这里的目录最后边一定要加否则就测试效果打开可选参数有以的方式进行格式化可选参数有修改为会以显示文件大小默认为以显示出件的确切显示件时间格式临时重定向永久重定向规则测试配置重定向会显示跳转的地址如果访问的地址没有匹配会默认使用第一个即指定参数中只要有字母就不走缓存前端页面资源后端服务使用名为的缓存空间对于状态码的数据缓存分钟定义生成缓存键的规则请求的参数作为缓存资源至少被重复访问次后再加入缓存出现重复请求时只让其中一个去后端读数据其他的从缓存中读取上面的锁超时时间为超过未获取数据其他请求直接去后端对于请求参数中有字母的不走缓存判断该变量是否有值如果有值则不进行缓存没有值则进行缓存在响应头中添加一个缓存是否命中的状态便于调试配置默认访问端口号为填写绑定证书的域名请填写证书文件的相对路径或绝对路径请填写私钥文件的相对路径或绝对路径停止通信时加密会话的有效期在该时间段内不需要重新交换密钥服务器支持的版本请按照以下套件配置配置加密套件写法遵循标准开启由服务器决定采用的密码套件指定参数中只要有字母就不走缓存前端页面资源后端服务指定哪些错误状态才执行重试使用名为的缓存空间对于状态码的数据缓存分钟定义生成缓存键的规则请求的参数作为缓存资源至少被重复访问次后再加入缓存出现重复请求时只让其中一个去后端读数据其他的从缓存中读取上面的锁超时时间为超过未获取数据其他请求直接去后端对于请求参数中有字母的不走缓存判断该变量是否有值如果有值则不进行缓存没有值则进行缓存在响应头中添加一个缓存是否命中的状态便于调试后端服务使用名为的缓存空间对于状态码的数据缓存分钟定义生成缓存键的规则请求的参数作为缓存资源至少被重复访问次后再加入缓存出现重复请求时只让其中一个去后端读数据其他的从缓存中读取上面的锁超时时间为超过未获取数据其他请求直接去后端对于请求参数中有字母的不走缓存判断该变量是否有值如果有值则不进行缓存没有值则进行缓存在响应头中添加一个缓存是否命中的状态便于调试',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-05-27 16:37:44',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2021/01/15/44ce857c1024a.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">晨空</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CICD/" style="font-size: 1.05rem;">CICD<sup>1</sup></a><a href="/tags/K8S/" style="font-size: 1.05rem;">K8S<sup>1</sup></a><a href="/tags/VPN/" style="font-size: 1.05rem;">VPN<sup>1</sup></a><a href="/tags/hexo/" style="font-size: 1.05rem;">hexo<sup>2</sup></a><a href="/tags/nginx/" style="font-size: 1.05rem;">nginx<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BF%90%E7%BB%B4/" itemprop="url">运维</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/nginx/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>nginx</span></a></span></div></div><h1 class="post-title" itemprop="name headline">nginx-一篇通</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-05-17T13:14:37.000Z" title="发表于 2024-05-17 21:14:37">2024-05-17</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-05-27T08:37:44.891Z" title="更新于 2024-05-27 16:37:44">2024-05-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">30k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>126分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为北京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>北京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/tupian/nginx-top.jpeg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/05/17/nginx/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/"><header><a class="post-meta-categories" href="/categories/%E8%BF%90%E7%BB%B4/" itemprop="url">运维</a><a href="/tags/nginx/" tabindex="-1" itemprop="url">nginx</a><h1 id="CrawlerTitle" itemprop="name headline">nginx-一篇通</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">晨空</span><time itemprop="dateCreated datePublished" datetime="2024-05-17T13:14:37.000Z" title="发表于 2024-05-17 21:14:37">2024-05-17</time><time itemprop="dateCreated datePublished" datetime="2024-05-27T08:37:44.891Z" title="更新于 2024-05-27 16:37:44">2024-05-27</time></header><h1 id="nginx-一把梭！（超详细讲解-实操）"><a href="#nginx-一把梭！（超详细讲解-实操）" class="headerlink" title="nginx 一把梭！（超详细讲解+实操）"></a>nginx 一把梭！（超详细讲解+实操）</h1><p>原创 蝎子莱莱爱打怪 <a href="javascript:void(0);">稀土掘金技术社区</a> <em>2023-12-10 09:31</em> <em>重庆</em></p>
<p><strong>稀土掘金技术社区</strong></p>
<p>掘金，一个帮助开发者成长的技术社区</p>
<p>740篇原创内容</p>
<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>nginx作为当今火爆的、高性能的http及反向代理服务，不管前端还是后端，都需要全面去了解，学习，实操。一句话：搞懂nginx如何使用以及工作逻辑对于程序员来说是必不可少的！</p>
<p>我们看看本文的大纲 先了解一下本文都讲了哪些东西，大纲如下：</p>
<ol>
<li>nginx介绍</li>
<li>nginx安装</li>
<li>nginx目录一览</li>
<li>nginx.conf文件解读</li>
<li>location路由匹配规则</li>
<li>反向代理</li>
<li>负载均衡</li>
<li>动静分离</li>
<li>跨域</li>
<li>缓存</li>
<li>黑白名单</li>
<li>nginx限流</li>
<li>https配置</li>
<li>压缩</li>
<li>其他一些常用指令与说明</li>
<li>重试策略</li>
<li>最后总结</li>
</ol>
<p><strong>「一些说明：」</strong></p>
<ol>
<li>系统： centos7</li>
<li>本文使用nginx版本：nginx&#x2F;1.24.0</li>
<li>关于nginx如何安装（本文不再赘述），参考之前我的一篇文章：Centos7中安装nginx</li>
<li>在学习nginx前，最好需要知道或者了解事件驱动思想以及几种常见多路复用I&#x2F;O模型和Reactor模式，这样你才能从底层 更深刻的理解nginx的架构设计</li>
</ol>
<h1 id="1、nginx-介绍"><a href="#1、nginx-介绍" class="headerlink" title="1、nginx 介绍"></a>1、nginx 介绍</h1><p>为了有一个全面的认知，接下来我们先来看看nginx的架构以及一些特点。</p>
<h2 id="1-1、nginx-特点"><a href="#1-1、nginx-特点" class="headerlink" title="1.1、nginx 特点"></a>1.1、nginx 特点</h2><ol>
<li>处理响应请求快（异步非阻塞I&#x2F;O，零拷贝，mmap，缓存机制）</li>
<li>扩展性好（模块化设计）</li>
<li>内存消耗低（异步非阻塞，多阶段处理）</li>
<li>具有很高的可靠性（无数次的生产验证，很多头部公司都在用）</li>
<li>热部署</li>
<li>高并发连接（事件驱动模型，多进程机制）</li>
<li>自由的BSD许可协议（可以自己修改代码后发布，包容性极强）</li>
</ol>
<h2 id="1-2、nginx-架构"><a href="#1-2、nginx-架构" class="headerlink" title="1.2、nginx 架构"></a>1.2、nginx 架构</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640.png" alt="图片">从上边这张图，我们可以一览nginx的架构设计，首先我们可以直观得出<code>nginx的几大特点：</code></p>
<ol>
<li><p><strong>「事件驱动&amp;异步非阻塞：」</strong></p>
<blockquote>
<p>❝</p>
<p>本质来说，<strong>「事件驱动是一种思想（事实上它不仅仅局限于编程）」</strong> ，事件驱动思想是实现 <strong>「异步非阻塞特性」</strong> 的一个重要手段。对于web服务器来说，造成性能拉胯不支持高并发的常见原因就是由于使用了传统的I&#x2F;O模型造成在<code>内核没有可读/可写事件（或者说没有数据可供用户进程读写）时</code>，<strong>「用户线程」</strong> <code>一直在等待</code>（其他事情啥也干不了就是干等等待内核上的数据可读&#x2F;可写），这样的话其实是一个线程（ps:线程在Linux系统也是进程）对应一个请求，请求是无限的，而线程是有限的从而也就形成了并发瓶颈。而大佬们为了解决此类问题，运用了事件驱动思想来对传统I&#x2F;O模型做个改造，即在客户端发起请求后，用户线程<code>不再阻塞等待内核数据就绪</code>，而是<code>立即返回</code>（可以去执行其他业务逻辑或者继续处理其他请求）。当内核的I&#x2F;O操作完成后，<code>内核系统</code>会向用户线程<code>发送一个事件通知</code>，用户线程才来处理这个读&#x2F;写操作，之后拿到数据再做些其他业务后响应给客户端，从而完成一次客户端请求的处理。事件驱动的I&#x2F;O模型中，程序不必阻塞等待I&#x2F;O操作的完成，也无需为每个请求创建一个线程，从而提高了系统的并发处理能力和响应速度。<code>事件驱动型的I/O模型通常也被被称为I/O多路复用</code>，即这种模型可以在一个线程中，处理多个连接（复用就是指多个连接复用一个线程，多路也即所谓的 多个连接），通过这种方式避免了线程间切换的开销，同时也使得用户线程不再被阻塞，提高了系统的性能和可靠性。nginx支持事件驱动是因为他利用了操作系统提供的I&#x2F;O多路复用接口，如Linux系统中，常用的I&#x2F;O多路复用接口有select&#x2F;poll，epoll。这些接口可以监视多个文件描述符的状态变化，当文件描述符可读或可写时，就会向用户线程发送一个事件通知。用户线程通过事件处理机制（读取&#x2F;写入数据）来处理这个事件，之后进行对应的业务逻辑完了进行响应。<strong>「简单一句话概括：」</strong> <code>事件驱动机制就是指当有读/写/连接事件就绪时 再去做读/写/接受连接这些事情，而不是一直在那里傻傻的等，也正应了他的名词： 【事件驱动！】，基于事件驱动思想设计的多路复用I/O（如select/poll，epoll），相对于传统I/O模型，达到了异步非阻塞的效果！</code></p>
<p>既然提到了select&#x2F;poll,epoll 那么我们就简单说一下（注意我这里是简单描述，后续有时间会对相关知识点从源码层面做个系统的整理和图解）：</p>
<p><strong>「select：」</strong> 将已连接的 Socket 都放到一个文件描述符集合，然后用户态调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。</p>
<p><strong>「poll：」</strong> poll函数的话其实和select大差不差，唯一区别可能就是socket列表的结构有所不同，不再受FD_SETSIZE的限制。这里就不多说了。</p>
<p><strong>「epoll：」</strong> epoll在前边两者的基础上做了很大的优化，select&#x2F;poll都需要遍历整个socket列表，当检测到传入的socket可读&#x2F;可写时，则copy socket列表给用户空间，用户态仍然需要遍历（因为内核copy给用户态的是整个socket列表）   ，而epoll则是通过红黑树结构将需要监控的socket插入到进去，然后当有socket可读时会通过回调机制来将其添加到可读列表中，然后内核将可读列表copy给用户态即可(据说此处使用了mmap这里我们不去验证探究，后续写相关文章时在深究吧)，整个过程少了无效的遍历以及不用copy整个socket集合。</p>
<p>❞</p>
</blockquote>
</li>
<li><p><strong>「多进程机制：」</strong></p>
<blockquote>
<p>❝</p>
<p>另外可以得知nginx有两种类型的进程，一种是Master主进程，一种是Worker工作进程。主进程主要负责3项工作：<code>加载配置</code>、<code>启动工作进程</code>及<code>非停升级</code>。另外work进程是主进程启动后，fork而来的。假设 Nginx fork了多个(具体在于你的配置)Worker进程，并且在Master进程中通过 socket 套接字监听（listen）80端口。然后每个worker进程都可以去 accept 这个监听的 socket。 当一个连接进来后，所有Worker进程，都会收到消息，但是只有一个Worker进程可以 accept 这个连接，其它的则 accept 失败，Nginx 保证只有一个Worker去accept的方式就是加锁（accept_mutex）。有了锁之后，在同一时刻，就只会有一个Worker进程去 accpet 连接，在 Worker 进程拿到 Http 请求后，就开始按照worker进程内的预置模块去处理该 Http 请求，最后返回响应结果并断开连接。其实如果熟悉reactor模型你会发现，nginx的设计有reactor的影子，只不过reactor的主reactor是会负责accept的，而nginx的主进程（对应主reactor） 是不会去accept的，而是交给了worker进程来处理。</p>
<p>worker进程除了accept连接之外，还会执行：网络读写、存储读写、内容传输、以及请求分发等等。而其代码的模块化设计，也使得我们可以根据需要对功能模块 进行适当的选择和修改，编译成符合特定需要&#x2F;业务的服务器</p>
<p>❞</p>
</blockquote>
</li>
<li><p><strong>「proxy cache（服务端缓存）：」</strong></p>
<blockquote>
<p>❝</p>
<p>proxy cache主要实现 nginx 服务器对客户端数据请求的快速响应。nginx 服务器在接收到被代理服务器的响应数据之后，一方面将数据传递给客户端，另一方面根据proxy cache的配置将这些数据缓存到本地硬盘上。当客户端再次访问相同的数据时，nginx服务器直接从硬盘检索到相应的数据返回给用户，从而减少与被代理服务器交互的时间。在缓存数据时，运用了零拷贝以及mmap技术，使得数据copy性能大幅提升。</p>
<p>❞</p>
</blockquote>
</li>
<li><p><strong>「反向代理：」</strong></p>
<blockquote>
<p>❝</p>
<p>nginx的强大之处其中一个就是他的反向代理，通过反向代理，可以隐藏真正的服务，增加其安全性，同时便于统一管理处理请求，另外可以很容易的做个负载均衡，更好的面对高并发的场景。</p>
<p>❞</p>
</blockquote>
</li>
</ol>
<h2 id="1-3、nginx模块"><a href="#1-3、nginx模块" class="headerlink" title="1.3、nginx模块"></a>1.3、nginx模块</h2><blockquote>
<p>❝</p>
<p>nginx服务器由n多个模块组成，每个模块就是一个功能，某个模块只负责自身的功能，所以说对于 <strong>「<code>“高内聚，低耦合“</code>」</strong> 的编程规则，在<code>nginx</code>身上可谓<code>体现的淋漓尽致</code>。</p>
<p>❞</p>
</blockquote>
<p><strong>「nginx模块示意图如下：」</strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-17159515206821.png" alt="图片"></p>
<ul>
<li><strong>「核心模块」</strong> ：是nginx 服务器正常运行必不可少的模块，提供错误日志记录、配置文件解析、事件驱动 机制、进程管理等核心功能</li>
<li><strong>「标准HTTP模块」</strong> ：提供 HTTP 协议解析相关的功能，如：端口配置、网页编码设置、HTTP 响应头设 置等</li>
<li><strong>「可选HTTP模块」</strong> ：主要用于扩展标准的 HTTP 功能，让nginx能处理一些特殊的服务，如：Flash 多 媒体传输、解析 GeoIP 请求、SSL 支持等</li>
<li><strong>「邮件服务模块」</strong> ：主要用于支持 nginx  的邮件服务，包括对 POP3 协议、IMAP 协议和 SMTP 协议的支持</li>
<li><strong>「第三方模块」</strong> ：是为了扩展 Nginx 服务器应用，完成开发者自定义功能，如：Json 支持、Lua 支持等</li>
</ul>
<h2 id="1-4、nginx常见应用场景"><a href="#1-4、nginx常见应用场景" class="headerlink" title="1.4、nginx常见应用场景"></a>1.4、nginx常见应用场景</h2><p>nginx常用场景挺多的，比如：</p>
<ul>
<li>反向代理</li>
<li>负载均衡</li>
<li>缓存</li>
<li>限流</li>
<li>黑&#x2F;白名单</li>
<li>静态资源服务</li>
<li>动静分离</li>
<li>防盗链</li>
<li>跨域</li>
<li>高可用</li>
<li>…….</li>
</ul>
<p>其中我认为 <strong>「最最」</strong> 基础的也是应用最多的就是 <strong>「反向代理」</strong>，这里我们画个图简单看下什么是反向代理 （ps：其他的那些使用场景，我们先不做展开，放到下边一个个哔哔。）</p>
<p>所谓反向代理，其实很好理解就是代理的服务端（与之对应的正向代理一般代理的是客户端），<strong>「nginx反向代理如下示意：」</strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-17159515206822.png" alt="图片"></p>
<hr>
<p><strong>「好了介绍了这么多，想必到这里应该对nginx有个大体的了解了吧，接下来我们安装并一个一个的分析介绍nginx的知识点。」</strong></p>
<h1 id="2、nginx安装"><a href="#2、nginx安装" class="headerlink" title="2、nginx安装"></a>2、nginx安装</h1><p>关于nginx的安装在这里不再赘述，参考我之前的一篇文章：Centos7中安装nginx</p>
<h1 id="3、nginx目录一览"><a href="#3、nginx目录一览" class="headerlink" title="3、nginx目录一览"></a>3、nginx目录一览</h1><p>我们使用 tree &#x2F;usr&#x2F;local&#x2F;nginx&#x2F; -L 2 命令查看一下nginx的目录，对其结构有个初步的认识：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# tree  /usr/local/nginx/  -L 2</span><br><span class="line">/usr/local/nginx/</span><br><span class="line">├── conf                        #存放一系列配置文件的目录</span><br><span class="line">│   ├── fastcgi.conf           #fastcgi程序相关配置文件</span><br><span class="line">│   ├── fastcgi.conf.default   #fastcgi程序相关配置文件备份</span><br><span class="line">│   ├── fastcgi_params         #fastcgi程序参数文件</span><br><span class="line">│   ├── fastcgi_params.default #fastcgi程序参数文件备份</span><br><span class="line">│   ├── koi-utf           #编码映射文件</span><br><span class="line">│   ├── koi-win           #编码映射文件</span><br><span class="line">│   ├── mime.types        #媒体类型控制文件</span><br><span class="line">│   ├── mime.types.default#媒体类型控制文件备份</span><br><span class="line">│   ├── nginx.conf        #主配置文件</span><br><span class="line">│   ├── nginx.conf.default#主配置文件备份</span><br><span class="line">│   ├── scgi_params      #scgi程序相关配置文件</span><br><span class="line">│   ├── scgi_params.default #scgi程序相关配置文件备份</span><br><span class="line">│   ├── uwsgi_params       #uwsgi程序相关配置文件</span><br><span class="line">│   ├── uwsgi_params.default#uwsgi程序相关配置文件备份</span><br><span class="line">│   └── win-utf          #编码映射文件</span><br><span class="line">├── html                 #存放网页文档</span><br><span class="line">│   ├── 50x.html         #错误页码显示网页文件</span><br><span class="line">│   └── index.html       #网页的首页文件</span><br><span class="line">├── logs                 #存放nginx的日志文件</span><br><span class="line">├── nginx-1.23.0.tar.gz # 我把压缩包下载到url/local/nginx/目录了，不用管这个</span><br><span class="line">├── sbin                #存放启动程序</span><br><span class="line">│   ├── nginx           #nginx启动程序</span><br><span class="line">│   └── nginx.old       </span><br><span class="line">└── test                # 我自己建的目录，不用管这个</span><br><span class="line">    ├── abc</span><br><span class="line">    └── cba</span><br><span class="line"></span><br><span class="line">15 directories, 26 files</span><br></pre></td></tr></table></figure>

<p>从输出可以看到nginx分的很清晰，有配置目录，html目录，log目录，启动程序目录。</p>
<ul>
<li><p><strong>「关于目录的一点小说明：」</strong></p>
<p>上边的仅仅是nginx的主目录，事实上，生效的主配置文件一定是&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf.conf ？这不一定，而是取决于你启动nginx时候有没有指定nginx.conf，实际使用中我发现我机器上有好几个地方都存在nginx.conf文件，使用 locate nginx.conf看一下 如下图所示：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)那如何确定nginx当前生效的是哪个nginx.conf呢，很简单使用nginx -T命令即可查看当前生效的nginx.conf，如下：可以看到我当前生效的是 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf这个文件（我是使用的 systemctl start nginx.service命令启动的，未指定用哪个文件启动，所以可以看出默认使用的是 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf这个配置文件）<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-17159515206823.png" alt="图片">另外还有一个就是nginx的日志，我发现我的nginx日志就不是在 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;这个目录下，而是放到了&#x2F;var&#x2F;log&#x2F;nginx&#x2F; 这个目录下了（ps：log文件的存放和我的nginx.conf文件中的 access_log配置有关系）。如下演示：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-17159515206824.png" alt="图片"></p>
</li>
</ul>
<p>好了在了解了nginx整体的目录结构后，就来看看 <strong>「nginx.conf」</strong> 这个文件这个文件是nginx的核心配置，<strong>「想玩转nginx，读懂这个配置文件是必不可少的一项基本功！」</strong></p>
<h1 id="4、nginx-conf文件-解读"><a href="#4、nginx-conf文件-解读" class="headerlink" title="4、nginx.conf文件 解读"></a>4、nginx.conf文件 解读</h1><p>首先我们要知道<code>nginx.conf文件是由一个一个的指令块组成的</code>，nginx用{}标识一个指令块，指令块中再设置具体的指令(注意 指令必须以 ; 号结尾)，指令块有<code>全局块</code>，<code>events块</code>，<code>http块</code>，<code>server块</code>和<code>localtion块 以及 upstream块</code>。精简后的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局模块</span><br><span class="line">event模块</span><br><span class="line">http模块</span><br><span class="line">    upstream模块</span><br><span class="line">    </span><br><span class="line">    server模块</span><br><span class="line">        localtion块</span><br><span class="line">        localtion块</span><br><span class="line">        ....</span><br><span class="line">    server模块</span><br><span class="line">        localtion块</span><br><span class="line">        localtion块</span><br><span class="line">        ...</span><br><span class="line">    ....    </span><br></pre></td></tr></table></figure>

<p><strong>「各模块的功能作用如下描述：」</strong></p>
<ol>
<li><strong>「全局模块：」</strong> 配置影响nginx全局的指令，比如运行nginx的用户名，nginx进程pid存放路径，日志存放路径，配置文件引入，worker进程数等。</li>
<li><strong>「events块：」</strong> 配置影响nginx服务器或与用户的网络连接。比如每个进程的最大连接数，选取哪种事件驱动模型（select&#x2F;poll epoll或者是其他等等nginx支持的）来处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li>
<li><strong>「http块：」</strong> 可以嵌套多个server，配置代理，缓存，日志格式定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li>
<li><strong>「server块：」</strong> 配置虚拟主机的相关参数比如域名端口等等，一个http中可以有多个server。</li>
<li><strong>「location块：」</strong> 配置url路由规则</li>
<li><strong>「upstream块：」</strong> 配置上游服务器的地址以及负载均衡策略和重试策略等等</li>
</ol>
<p><strong>「下面看下nginx.conf长啥样并对一些指令做个解释：」</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 注意：有些指令是可以在不同指令块使用的（需要时可以去官网看看对应指令的作用域）。我这里只是演示</span><br><span class="line"># 这里我以/usr/local/nginx/conf/nginx.conf文件为例</span><br><span class="line"></span><br><span class="line">[root@localhost /usr/local/nginx]# cat /usr/local/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">#user  nobody; # 指定Nginx Worker进程运行用户以及用户组，默认由nobody账号运行</span><br><span class="line">worker_processes  1;  # 指定工作进程的个数，默认是1个。具体可以根据服务器cpu数量进行设置， 比如cpu有4个，可以设置为4。如果不知道cpu的数量，可以设置为auto。 nginx会自动判断服务器的cpu个数，并设置相应的进程数</span><br><span class="line">#error_log  logs/error.log;  # 用来定义全局错误日志文件输出路径，这个设置也可以放入http块，server块，日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info; # 指定error日志位置和日志级别</span><br><span class="line">#pid        logs/nginx.pid;  # 用来指定进程pid的存储文件位置</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    accept_mutex on;   # 设置网路连接序列化，防止惊群现象发生，默认为on</span><br><span class="line">    </span><br><span class="line">    # Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll，其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中，对于Linux系统，epoll工作模式是首选</span><br><span class="line">    use epoll;</span><br><span class="line">    </span><br><span class="line">    # 用于定义Nginx每个工作进程的最大连接数，默认是1024。最大客户端连接数由worker_processes和worker_connections决定，即Max_client=worker_processes*worker_connections在作为反向代理时，max_clients变为：max_clients = worker_processes *worker_connections/4。进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit -n 65536”后worker_connections的设置才能生效</span><br><span class="line">    worker_connections  1024; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 对HTTP服务器相关属性的配置如下</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types; # 引入文件类型映射文件 </span><br><span class="line">    default_type  application/octet-stream; # 如果没有找到指定的文件类型映射 使用默认配置 </span><br><span class="line">    # 设置日志打印格式</span><br><span class="line">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">    # </span><br><span class="line">    #access_log  logs/access.log  main; # 设置日志输出路径以及 日志级别</span><br><span class="line">    sendfile        on; # 开启零拷贝 省去了内核到用户态的两次copy故在文件传输时性能会有很大提升</span><br><span class="line">    #tcp_nopush     on; # 数据包会累计到一定大小之后才会发送，减小了额外开销，提高网络效率</span><br><span class="line">    keepalive_timeout  65; # 设置nginx服务器与客户端会话的超时时间。超过这个时间之后服务器会关闭该连接，客户端再次发起请求，则需要再次进行三次握手。</span><br><span class="line">    #gzip  on; # 开启压缩功能，减少文件传输大小，节省带宽。</span><br><span class="line">    sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br><span class="line">    </span><br><span class="line">    # 配置你的上游服务（即被nginx代理的后端服务）的ip和端口/域名</span><br><span class="line">    upstream backend_server &#123; </span><br><span class="line">        server 172.30.128.65:8080;</span><br><span class="line">        server 172.30.128.65:8081 backup; #备机</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80; #nginx服务器监听的端口</span><br><span class="line">        server_name  localhost; #监听的地址 nginx服务器域名/ip 多个使用英文逗号分割</span><br><span class="line">        #access_log  logs/host.access.log  main; # 设置日志输出路径以及 级别，会覆盖http指令块的access_log配置</span><br><span class="line">        </span><br><span class="line">        # localtion用于定义请求匹配规则。 以下是实际使用中常见的3中配置（即分为：首页，静态，动态三种）</span><br><span class="line">       </span><br><span class="line">        # 第一种：直接匹配网站根目录，通过域名访问网站首页比较频繁，使用这个会加速处理，一般这个规则配成网站首页，假设此时我们的网站首页文件就是： usr/local/nginx/html/index.html</span><br><span class="line">        location = / &#123;  </span><br><span class="line">            root   html; # 静态资源文件的根目录 比如我的是 /usr/local/nginx/html/</span><br><span class="line">            index  index.html index.htm; # 静态资源文件名称 比如：网站首页html文件</span><br><span class="line">        &#125;</span><br><span class="line">        # 第二种：静态资源匹配（静态文件修改少访问频繁，可以直接放到nginx或者统一放到文件服务器，减少后端服务的压力），假设把静态文件我们这里放到了 usr/local/nginx/webroot/static/目录下</span><br><span class="line">        location ^~ /static/ &#123;</span><br><span class="line">            alias /webroot/static/; 访问 ip:80/static/xxx.jpg后，将会去获取/url/local/nginx/webroot/static/xxx.jpg 文件并响应</span><br><span class="line">        &#125;</span><br><span class="line">        # 第二种的另外一种方式：拦截所有 后缀名是gif,jpg,jpeg,png,css.js,ico这些 类静态的的请求，让他们都去直接访问静态文件目录即可</span><br><span class="line">        location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line">            root /webroot/static/;</span><br><span class="line">        &#125;</span><br><span class="line">        # 第三种：用来拦截非首页、非静态资源的动态数据请求，并转发到后端应用服务器 </span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://backend_server; #请求转向 upstream是backend_server 指令块所定义的服务器列表</span><br><span class="line">            deny 192.168.3.29; #拒绝的ip （黑名单）</span><br><span class="line">            allow 192.168.5.10; #允许的ip（白名单）</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        # 定义错误返回的页面，凡是状态码是 500 502 503 504 总之50开头的都会返回这个 根目录下html文件夹下的50x.html文件内容</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    # 其余的server配置 ,如果有需要的话</span><br><span class="line">    #server &#123;</span><br><span class="line">        ......</span><br><span class="line">    #    location / &#123;</span><br><span class="line">               ....</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line">    </span><br><span class="line">    # include /etc/nginx/conf.d/*.conf;  # 一般我们实际使用中有很多配置，通常的做法并不是将其直接写到nginx.conf文件，</span><br><span class="line">    # 而是写到新文件 然后使用include指令 将其引入到nginx.conf即可，这样使得主配置nginx.conf文件更加清晰。</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是nginx.conf文件的配置了，主要讲了一些指令的含义，当然实际的指令有很多，我在配置文件并没有全部写出来，准备放到后边章节详细阐述这些东西，比如：<strong>「localtion匹配规则，反向代理，动静分离，负载均衡策略，重试策略，压缩，https,限流，缓存，跨域这些」</strong> 我们都没细说，这些东西比较多比较细不可能把使用规则和细节都写到上边的配置文件中，所以我们下边一一解释说明关于这些东西的配置和使用方式。（另外值的注意的是： 因为有些指令是可以在不同作用域使用的，如果在多个作用域都有相同指令的使用，那么nginx将会遵循就近原则或者我愿称之为 <strong>「内层配置优先」</strong>。 eg: 你在 http配了日志级别，也在某个server中配了日志级别，那么这个server将使用他自己配置的已不使用外层的http日志配置）</p>
<h1 id="5、localtion-路由匹配规则"><a href="#5、localtion-路由匹配规则" class="headerlink" title="5、localtion 路由匹配规则"></a>5、localtion 路由匹配规则</h1><p><strong>「什么是location? :」</strong> nginx根据用户请求的URI来匹配对应的location模块，匹配到哪个location，请求将被哪个location块中的配置项所处理。</p>
<p>location配置语法：<code>location [修饰符] pattern &#123;…&#125;</code></p>
<p><strong>「常见匹配规则如下：」</strong></p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">空</td>
<td align="left">无修饰符的前缀匹配，匹配前缀是 你配置的（比如说你配的是 &#x2F;aaa） 的url</td>
</tr>
<tr>
<td align="left">&#x3D;</td>
<td align="left">精确匹配</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">正则表达式模式匹配，区分大小写</td>
</tr>
<tr>
<td align="left">~*</td>
<td align="left">正则表达式模式匹配，不区分大小写</td>
</tr>
<tr>
<td align="left">^~</td>
<td align="left">^~类型的前缀匹配，类似于无修饰符前缀匹配，不同的是，如果匹配到了，那么就停止后续匹配</td>
</tr>
<tr>
<td align="left">&#x2F;</td>
<td align="left">通用匹配，任何请求都会匹配到（只要你域名对，所有请求通吃！）</td>
</tr>
</tbody></table>
<h2 id="5-1、前缀匹配（无修饰符）"><a href="#5-1、前缀匹配（无修饰符）" class="headerlink" title="5.1、前缀匹配（无修饰符）"></a>5.1、前缀匹配（无修饰符）</h2><p>首先我提前创建了prefix_match.html文件，之后改一下nginx.conf文件（给前缀是 &#x2F;prefixmatch 的请求返回 &#x2F;etc&#x2F;nginx&#x2F;locatest&#x2F;prefix_match.html 这个文件） ，如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-17159515206825.png" alt="图片"></p>
<p>然后在宿主机hosts中配置域名 172.30.128.65 <a target="_blank" rel="noopener" href="http://www.locatest.com/">www.locatest.com</a> 映射后，观察到nginx服务器返回内容如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-17159515206826.png" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://www.locatest.com/prefixmatch     ✅ 301</span><br><span class="line">curl http://www.locatest.com/prefixmatch?    ✅ 301</span><br><span class="line">curl http://www.locatest.com/PREFIXMATCH     ❌ 404</span><br><span class="line">curl http://www.locatest.com/prefixmatch/    ✅ 200</span><br><span class="line">curl http://www.locatest.com/prefixmatchmmm  ❌ 404</span><br><span class="line">curl http://www.locatest.com/prefixmatch/mmm ❌ 404</span><br><span class="line">curl http://www.locatest.com/aaa/prefixmatch/❌ 404</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>域名/prefixmatch</code> 和<code>域名/prefixmatch?</code> 返回了301 ，原因在于prefixmatch映射的 &#x2F;etc&#x2F;nginx&#x2F;locatest&#x2F; 是个目录，而不是个文件所以nginx提示我们301，这个我们不用管没关系，总之我们知道：<code>域名/prefixmatch</code>，<code>域名/prefixmatch?</code> 和<code>域名/prefixmatch/</code> 这三个url通过我们配置的 <strong>「无修饰符前缀匹配规则」</strong> 都能匹配上就行了。</p>
<p>ps：为了方便，我们下边的几个location规则演示不再跳转静态文件了，而是直接return一句话。</p>
<h2 id="5-2、精确匹配（-）"><a href="#5-2、精确匹配（-）" class="headerlink" title="5.2、精确匹配（ &#x3D; ）"></a>5.2、精确匹配（ &#x3D; ）</h2><p>为了演示精确匹配，我们再给nginx.conf文件增加一个location配置，如下标红处：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-17159515206827.png" alt="图片"></p>
<p>实际效果如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-17159515206838.png" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.locatest.com/exactmatch      ✅ 200</span><br><span class="line">http://www.locatest.com/exactmatch？    ✅ 200</span><br><span class="line">http://www.locatest.com/exactmatch/     ❌ 404</span><br><span class="line">http://www.locatest.com/exactmatchmmmm  ❌ 404</span><br><span class="line">http://www.locatest.com/EXACTMATCH      ❌ 404</span><br></pre></td></tr></table></figure>

<p>可以看出来精确匹配就是精确匹配，差一个字也不行！</p>
<h2 id="5-3、前缀匹配（-）"><a href="#5-3、前缀匹配（-）" class="headerlink" title="5.3、前缀匹配（ ^~ ）"></a>5.3、前缀匹配（ ^~ ）</h2><p>我们上边说了不带任何修饰符的前缀匹配（5.1小节），这里我们看下 修饰符是 ^~的 前缀匹配和不带修饰符的前缀匹配有啥区别，先在ngnx.conf文件增加个location并配好如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)curl效果如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://www.locatest.com/exactprefixmatch     ✅ 200</span><br><span class="line">curl http://www.locatest.com/exactprefixmatch/    ✅ 200</span><br><span class="line">curl http://www.locatest.com/exactprefixmatch?    ✅ 200</span><br><span class="line">curl http://www.locatest.com/exactprefixmatchmmm  ✅ 200</span><br><span class="line">curl http://www.locatest.com/exactprefixmatch/mmm ✅ 200</span><br><span class="line">curl http://www.locatest.com/aaa/exactprefixmatch ❌ 404</span><br><span class="line">curl http://www.locatest.com/EXACTPREFIXMATCH     ❌ 404</span><br></pre></td></tr></table></figure>

<p>可以看到带修饰符(<code>^~</code>)的前缀匹配 像：<code>域名/exactprefixmatchmmm</code> 和<code>域名/exactprefixmatch/mmm</code> 是可以匹配上的，而不带修饰符的前缀匹配这两个类型的url是匹配不上的直接返回了404 ，其他的和不带修饰符的前缀匹配似乎都差不多。</p>
<h2 id="5-4、正则匹配（-区分大小写）"><a href="#5-4、正则匹配（-区分大小写）" class="headerlink" title="5.4、正则匹配（~ 区分大小写）"></a>5.4、正则匹配（~ 区分大小写）</h2><p>ps：正则表达式的匹配，需要你对正则语法比较熟悉，熟悉语法后写匹配规则也就得心应手了。</p>
<p>添加个location并配置，如下：（  ^表示开头，$表示结尾）![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)实际效果如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://www.locatest.com/regexmatch      ✅ 200</span><br><span class="line">curl http://www.locatest.com/regexmatch/     ❌ 404</span><br><span class="line">curl http://www.locatest.com/regexmatch?     ✅ 200</span><br><span class="line">curl http://www.locatest.com/regexmatchmmm   ❌ 404</span><br><span class="line">curl http://www.locatest.com/regexmatch/mmm  ❌ 404</span><br><span class="line">curl http://www.locatest.com/REGEXMATCH      ❌ 404</span><br><span class="line">curl http://www.locatest.com/aaa/regexmatch  ❌ 404</span><br><span class="line">curl http://www.locatest.com/bbbregexmatch   ❌ 404</span><br></pre></td></tr></table></figure>

<p>可以看到~修饰的正则是区分大小写的。接下来我们看下 不区分大小写的匹配。</p>
<h2 id="5-5、正则匹配（-不区分大小写）"><a href="#5-5、正则匹配（-不区分大小写）" class="headerlink" title="5.5、正则匹配（~* 不区分大小写）"></a>5.5、正则匹配（~* 不区分大小写）</h2><p>改下location 在修饰符~后加个  <em><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-17159515206839.png" alt="图片">看下实际效果：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068310.png" alt="图片">可以看到这次 curl <a target="_blank" rel="noopener" href="http://www.locatest.com/REGEXMATCH">http://www.locatest.com/REGEXMATCH</a> 是可以匹配上的，说明 ~</em> 确实是不区分大小写的。</p>
<h2 id="5-6、通用匹配（-）"><a href="#5-6、通用匹配（-）" class="headerlink" title="5.6、通用匹配（ &#x2F; ）"></a>5.6、通用匹配（ &#x2F; ）</h2><p>通用匹配使用一个 &#x2F; 表示，可以匹配所有请求，一般nginx配置文件最后都会有一个通用匹配规则，当其他匹配规则均失效时，请求会被路由给通用匹配规则处理，如果没有配置通用匹配，并且其他所有匹配规则均失效时，nginx会返回404错误。![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)通用匹配实际效果：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068311.png" alt="图片">可以看到通用匹配很好理解，只要你域名写对了，那么所有的url都会被匹配上，来者不拒的感觉。</p>
<h2 id="5-7、关于location-匹配优先级"><a href="#5-7、关于location-匹配优先级" class="headerlink" title="5.7、关于location 匹配优先级"></a>5.7、关于location 匹配优先级</h2><p>上边我们说了6种location匹配规则，那么如果存在多个到底走哪个location呢？这就的说说location的匹配优先级了。先来看下nginx官网和stackoverflow上的资料如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068312.png" alt="图片">![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)综上资料我们对<strong>「location匹配优先级的总结如下：」</strong></p>
<ol>
<li>优先走<code>精确匹配</code>，精确匹配命中时，直接走对应的location，停止之后的匹配动作。</li>
<li><code>无修饰符类型的前缀匹配</code>和 <code>^~ 类型的前缀匹配</code>命中时，收集命中的匹配，对比出最长的那一条并存起来(最长指的是与请求url匹配度最高的那个location)。</li>
<li><code>如果</code>步骤2中最长的那一条匹配<code>是^~类型的前缀匹配</code>，直接走此条匹配对应的location并<code>停止</code>后续匹配动作；如果步骤2<code>最长的那一条匹配</code>不是^~类型的前缀匹配（也就<code>是无修饰符的前缀匹配</code>），则<code>继续往下</code>匹配</li>
<li>按location的声明顺序，执行正则匹配，当找到第一个命中的正则location时，停止后续匹配。</li>
<li>都没匹配到，走通用匹配（ &#x2F; ）（如果有配置的话），如果没配置通用匹配的话，上边也都没匹配上，到这里就是404了。</li>
</ol>
<p><strong>「如果非要给修饰符排个序的话就是酱样子：」</strong><code>=</code> &gt;  <code>^~</code> &gt; <code>正则</code> &gt; <code>无修饰符的前缀匹配</code> &gt; <code>/</code></p>
<p>ok关于location就到这里，location是一个很重要的点，学好这个才知道nginx到底是咋匹配url的。</p>
<h1 id="6、反向代理"><a href="#6、反向代理" class="headerlink" title="6、反向代理"></a>6、反向代理</h1><p>反向代理示意图我们上边说过，这里再次粘一下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-17159515206822.png" alt="图片"></p>
<p>接下来我们开始用一个小demo来演示反向代理的使用</p>
<h2 id="6-1、服务准备"><a href="#6-1、服务准备" class="headerlink" title="6.1、服务准备"></a>6.1、服务准备</h2><p>首先将我本地的一个服务打成 胖jar：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)然后使用java -jar方式启动服务，且指定端口为8081：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar /Users/hzz/myself_project/xzll/study-admin/study-admin-service/target/study-admin-service.jar --server.port=8081</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068313.png" alt="图片">最后使用postman测试接口是否正常（注意此时还没被nginx代理，而是直接调的服务）：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068314.png" alt="图片">启动服务并验证接口无误后，接下来我们修改nginx配置文件。让nginx反向代理我们的服务。</p>
<h2 id="6-2、修改nginx-conf文件"><a href="#6-2、修改nginx-conf文件" class="headerlink" title="6.2、修改nginx.conf文件"></a>6.2、修改nginx.conf文件</h2><p>要让 <strong>「<code>nginx 代理</code>」</strong> 我们的 <strong>「<code>服务</code>」</strong> 很简单，简单描述一下就是 <strong>「<code>两步：</code>」</strong></p>
<ol>
<li><strong>「通过upstream指令块来定义我们的上游服务（即被代理的服务）」</strong></li>
<li><strong>「通过location指令块中的 proxy_pass指令，指定该location要路由到哪个upstream」</strong></li>
</ol>
<p>配置好1和2后，如果来了请求后 会通过url路由到对应的location, 然后nginx会将请求打到upstream定义的服务地址中去，下边我们看看：</p>
<p>使用 vi &#x2F;etc&#x2F;nginx&#x2F;nginx.conf命令修改nginx.conf文件，如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068315.png" alt="图片">（注意上边的 proxy_pass <a target="_blank" rel="noopener" href="http://mybackendserver/">http://mybackendserver/</a>  <strong>「后边这个斜线加和不加区别挺大的」</strong>，<code>加的话不会拼接/backend</code> , <code>而不加的话会拼接 /backend</code> ,这一点我们在15.5.3小节会讲到，这里留意下就好）</p>
<h2 id="6-3、测试反向代理"><a href="#6-3、测试反向代理" class="headerlink" title="6.3、测试反向代理"></a>6.3、测试反向代理</h2><p>修改完后我们执行 nginx -s reload 命令重新加载nginx配置，然后再potsman中调用一下，如下：</p>
<blockquote>
<p>❝</p>
<p>ps：在第一次调用中出现了一个错误: failed (13: Permission denied) while connecting to upstream：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)解决办法很简单在虚拟机执行命令：setenforce 0 来关闭<code>seLinux的限制</code>即可，或者参考：stackoverflow上的解决方案</p>
<p>❞</p>
</blockquote>
<p>解决后再次调用发现可以了：（注意 <a target="_blank" rel="noopener" href="http://www.proxytest.com/">www.proxytest.com</a> 是我随便写的域名没做dns解析，我是在请求发出方 宿主机 配了host，所以才能请求通）<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068316.png" alt="图片">同时也可使用命令  tail -n +1 -f access.log 观察到nginx日志输出如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068317.png" alt="图片"></p>
<h2 id="6-4、反向代理流程与原理"><a href="#6-4、反向代理流程与原理" class="headerlink" title="6.4、反向代理流程与原理"></a>6.4、反向代理流程与原理</h2><p>对于上边演示的反向代理案例的流程与原理，我们来个示意图如下：（这个图比较重要）<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068318.png" alt="图片"></p>
<p>接下来我们演示下负载均衡。</p>
<h1 id="7、负载均衡"><a href="#7、负载均衡" class="headerlink" title="7、负载均衡"></a>7、负载均衡</h1><p>说到负载均衡很多人应该并不陌生，总而言之负载均衡就是：避免高并发高流量时请求都聚集到某一个服务或者某几个服务上，而是让其均匀分配（或者能者多劳），从而减少高并发带来的系统压力，从而让服务更稳定。对于nginx来说，负载均衡就是从 <code>upstream</code> 模块定义的后端服务器列表中按照配置的负载策略选取一台服务器接受用户的请求。</p>
<h2 id="7-1、准备3个不同端口的springboot服务"><a href="#7-1、准备3个不同端口的springboot服务" class="headerlink" title="7.1、准备3个不同端口的springboot服务"></a>7.1、准备3个不同端口的springboot服务</h2><p>想要演示负载均衡，我们首先得多搞几个服务，搞一个服务是没法儿演示的。所以我启动了3个不同端口（8081，8082，8083）的springboot服务，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar /Users/hzz/myself_project/xzll/study-admin/study-admin-service/target/study-admin-service.jar --server.port=8081</span><br><span class="line">java -jar /Users/hzz/myself_project/xzll/study-admin/study-admin-service/target/study-admin-service.jar --server.port=8082</span><br><span class="line">java -jar /Users/hzz/myself_project/xzll/study-admin/study-admin-service/target/study-admin-service.jar --server.port=8083</span><br></pre></td></tr></table></figure>

<p>使用 command+D 对iterm2进行分屏 ，最左侧是8081端口，中间是8082，右侧是8083：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068319.png" alt="图片">接下来我们说一下负载策略再开始。</p>
<h2 id="7-2、nginx常用的负载策略"><a href="#7-2、nginx常用的负载策略" class="headerlink" title="7.2、nginx常用的负载策略:"></a>7.2、nginx常用的负载策略:</h2><table>
<thead>
<tr>
<th align="left">负载策略</th>
<th align="left">描述</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">轮询</td>
<td align="left">默认方式</td>
<td align="left">1. 每个请求会按时间顺序逐一分配到不同的后端服务器 2. 在轮询中，如果服务器down掉了，会自动剔除该服务器 3. 缺省配置就是轮询策略 4. 此策略适合服务器配置相当，无状态且短平快的服务使用</td>
</tr>
<tr>
<td align="left">weight</td>
<td align="left">权重方式</td>
<td align="left">1. 在轮询策略的基础上指定轮询的几率 2. 权重越高分配到的请求越多 3. 此策略可以与least_conn和ip_hash结合使用 4. 此策略比较适合服务器的硬件配置差别比较大的情况</td>
</tr>
<tr>
<td align="left">ip_hash</td>
<td align="left">依据ip的hash值来分配</td>
<td align="left">1. 在nginx版本1.3.1之前，不能在ip_hash中使用权重（weight） 2. ip_hash不能与backup同时使用 3. 此策略适合有状态服务，比如session 4. 当有服务器需要剔除，必须手动down掉</td>
</tr>
<tr>
<td align="left">least_conn</td>
<td align="left">最少连接方式</td>
<td align="left">1. 此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况</td>
</tr>
<tr>
<td align="left">fair（第三方）</td>
<td align="left">响应时间方式</td>
<td align="left">1. 根据后端服务器的响应时间来分配请求，响应时间短的优先分配 2. Nginx本身不支持fair，如果需要这种调度算法，则必须安装upstream_fair模块</td>
</tr>
<tr>
<td align="left">url_hash（第三方）</td>
<td align="left">依据URL分配方式</td>
<td align="left">1. 按访问的URL的哈希结果来分配请求，使每个URL定向到一台后端服务器 2. Nginx本身不支持url_hash，如果需要这种调度算法，则必须安装Nginx的hash软件包</td>
</tr>
</tbody></table>
<h3 id="7-2-1、轮询"><a href="#7-2-1、轮询" class="headerlink" title="7.2.1、轮询"></a>7.2.1、轮询</h3><p>轮询策略是默认的，所以只需要如下这样修改配置文件就可以了：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068320.png" alt="图片">重启nginx后观察一下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068321.png" alt="图片">以上图片可以看到，是按upstream中的先后顺序来进行轮询的。</p>
<h3 id="7-2-2、weight"><a href="#7-2-2、weight" class="headerlink" title="7.2.2、weight"></a>7.2.2、weight</h3><p>weight指令用于指定轮询机率，weight的默认值为1，weight的数值与访问比率成正比。 接下来我们指定8082端口的服务的weight&#x3D;2，如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068322.png" alt="图片">看下权重策略下的请求结果：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068323.png" alt="图片">可以看到在一轮轮询中，8081命中1次，8082由于配置了 weight&#x3D;2所以命中了2次，8083命中了1次。即配置了weight&#x3D;2的8082服务，命中几率是8081或者8083的两倍</p>
<h3 id="7-2-3、ip-hash"><a href="#7-2-3、ip-hash" class="headerlink" title="7.2.3、ip_hash"></a>7.2.3、ip_hash</h3><p>设定ip哈希很简单，就是在你的upstream中 指定 <code>ip_hash;</code>即可，如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)重启nginx后看下效果：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)可以看到，由于我的访问ip总是固定的宿主机的172.30.128.64 根据hash算法我的ip被匹配给了8083端口的服务，所以只要我不换ip 不管我请求多少次，请求都是被 转发到了8083的服务上了。</p>
<h3 id="7-2-4、least-conn"><a href="#7-2-4、least-conn" class="headerlink" title="7.2.4、least_conn"></a>7.2.4、least_conn</h3><p>同ip_hash一样，设定最小连接数策略也很简单，就是在你的upstream中 指定 <code>least_conn;</code>即可，如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)由于我这里最小连接数看不出啥效果，所以就不演示截图了，知道怎么配置最小连接数即可。关于第三方的负载策略。不做过多说明了，可以看看：nginx官方文档 获取其他的网上资料。</p>
<h1 id="8、动静分离"><a href="#8、动静分离" class="headerlink" title="8、动静分离"></a>8、动静分离</h1><p>在说动静分离前，我们要知道为何要做动静分离以及他能解决啥问题，首先，我们常见的web系统中会有大量的静态资源文件比如掘金主页面刷新后的f12如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)可以看到有很多静态资源，如果将这些资源都搞到后端服务的话，将会提高后端服务的压力且占用带宽增加了系统负载（要知道，静态资源的访问频率其实蛮高的）所以为了避免该类问题我们可以把不常修改的静态资源文件放到nginx的静态资源目录中去，这样在访问静态资源时直接读取nginx服务器本地文件目录之后返回，这样就大大减少了后端服务的压力同时也加快了静态资源的访问速度，何为静，何为动呢？：</p>
<ol>
<li><strong>「静：」</strong> 将不常修改且访问频繁的静态文件，放到nginx本地静态目录（当然也可以搞个静态资源服务器专门存放所有静态文件）</li>
<li><strong>「动：」</strong> 将变动频繁&#x2F;实时性较高的比如后端接口，实时转发到对应的后台服务</li>
</ol>
<p>接下来我们将构造一个html页面，然后点击按钮后发送get请求到后端接口。流程如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068324.png" alt="图片"></p>
<h2 id="8-1、准备工作"><a href="#8-1、准备工作" class="headerlink" title="8.1、准备工作"></a>8.1、准备工作</h2><p>首先我们搞个html（请原谅我这粗糙的前端代码😂😂）,内容如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068325.png" alt="图片">之后使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp /Users/hzz/fsdownload/index_page.html root@172.30.128.65:/usr/local/nginx/test/static</span><br></pre></td></tr></table></figure>

<p>命令将index_page.html 文件上传到虚拟机。</p>
<h2 id="8-2、修改nginx-conf文件"><a href="#8-2、修改nginx-conf文件" class="headerlink" title="8.2、修改nginx.conf文件"></a>8.2、修改nginx.conf文件</h2><p>首先我们配置俩location规则,一个（ &#x2F;frontend ）是读取静态文件，一个（&#x2F;backend）是转发到 我们配置的upstream服务中去。如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="8-3、演示"><a href="#8-3、演示" class="headerlink" title="8.3、演示"></a>8.3、演示</h2><p>首先我们在浏览器输入：<a target="_blank" rel="noopener" href="http://www.proxytest.com/frontend/">http://www.proxytest.com/frontend/</a> ，可以看到请求返回了一个html页面，其实就是我们刚才的  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;test&#x2F;static&#x2F;index_page.html文件![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)接着我们输入要查询的人名，之后点击 “调用get接口” 按钮，如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)返回数据：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)查看nginx访问日志可以看到两次请求的输出：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<p>ok到这里动静分离就演示完了，接下来我们看下跨域</p>
<h1 id="9、跨域"><a href="#9、跨域" class="headerlink" title="9、跨域"></a>9、跨域</h1><h2 id="9-1、为何会产生跨域？"><a href="#9-1、为何会产生跨域？" class="headerlink" title="9.1、为何会产生跨域？"></a>9.1、为何会产生跨域？</h2><p>产生跨域问题的主要原因就在于同源策略，为了保证用户信息安全，防止恶意网站窃取数据，同源策略是必须的，该政策由 Netscape 公司于1995年引入浏览器。目前，所有浏览器都实行这个政策。同源策略主要是指三点相同即：<strong>「协议+域名+端口 相同的两个请求」</strong>，则可以被看做<strong>「是同源」</strong>的，但如果<strong>「其中任意一点存在不同」</strong>，则代表是<strong>「两个不同源的请求」</strong>，同源策略会限制不同源之间的资源交互从而减少数据安全问题。</p>
<h2 id="9-2、跨域演示"><a href="#9-2、跨域演示" class="headerlink" title="9.2、跨域演示"></a>9.2、跨域演示</h2><p>首先我在nginx.conf文件中加一个server配置也即将前后端配成不同的server 并且监听的端口以及域名名称都不一致，从而<code>造成</code>访问<code>前端服务和后端服务</code>时候 这俩服务<code>不是&quot;同源&quot;</code>， 如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068326.png" alt="图片">之后我修改index_page中的后端地址：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068327.png" alt="图片">重启nginx，并配置宿主机的hosts文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">172.30.128.65 www.front.com</span><br><span class="line">172.30.128.65:90  www.backend.com</span><br></pre></td></tr></table></figure>

<p>之后在浏览器中测试一下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)可以看到浏览器提示我们受同源规则影响我们不能跨域访问资源。造成的原因是我的两个域名解析出来的端口不一致 一个是80一个是90。不符合同源策略，所以必然会有跨域报错。</p>
<h2 id="9-3、nginx解决跨域"><a href="#9-3、nginx解决跨域" class="headerlink" title="9.3、nginx解决跨域"></a>9.3、nginx解决跨域</h2><p>首先想解决跨越就得避免不同源，而我们可不可以 把对后端的代理 放在前端的server中呢（也就是说让前后端统一使用一个端口，一个server_name）？答案是可以的，因为server支持多个location配置呀（一个location处理前端，一个location转发后端），我们改下配置文件试一把如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068328.png" alt="图片">之后重启nginx后在浏览器输入  <a target="_blank" rel="noopener" href="http://www.xxxadminsystem.com/page/">http://www.xxxadminsystem.com/page/</a> ，效果如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068329.png" alt="图片">上边&#x2F;page请求返回了html页面之后我们输入参数点击“调用get接口”查看到后端接口的调用如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068330.png" alt="图片">![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)从上边可以看到，我上边设想的方式是可行的。</p>
<ul>
<li><p>当然有些资料上有说使用 设置header的方式解决跨域，但是在实际测试中，设置header的方式始终没解决跨域，试了好久也没解决掉😂😂，有试过此方式解决的大佬帮忙看看我这是哪里配错了还是咋的在此提前感谢了。</p>
<blockquote>
<p>❝</p>
<p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)image.png</p>
<p>❞</p>
</blockquote>
</li>
</ul>
<h1 id="10、缓存"><a href="#10、缓存" class="headerlink" title="10、缓存"></a>10、缓存</h1><p>在开头我们就介绍过，nginx代理缓存可以在某些场景下有效的减少服务器压力，让请求快速响应，从而提升用户体验和服务性能，那么nginx缓存如何使用呢？在使用及演示前我们先来熟悉下相关的配置以及其含义，知道了这些才能更好的使用nginx缓存。</p>
<h2 id="10-1、nginx缓存配置参数表格一览"><a href="#10-1、nginx缓存配置参数表格一览" class="headerlink" title="10.1、nginx缓存配置参数表格一览"></a>10.1、nginx缓存配置参数表格一览</h2><table>
<thead>
<tr>
<th align="left">指令名称</th>
<th align="left">作用解释</th>
<th align="left">语法</th>
<th align="left">默认配置</th>
<th align="left">示例</th>
<th align="left">作用域</th>
</tr>
</thead>
<tbody><tr>
<td align="left">proxy_cache</td>
<td align="left">设置是否开启对后端响应的缓存。</td>
<td align="left">proxy_cache zone | off;</td>
<td align="left">proxy_cache off;</td>
<td align="left">proxy_cache mycache; # 规定开启nginx缓存并且缓存名称为: mycache</td>
<td align="left">http, server, location</td>
</tr>
<tr>
<td align="left">proxy_cache_valid</td>
<td align="left">配置什么状态码可以被缓存，以及缓存时长</td>
<td align="left">proxy_cache_valid [code …] time;</td>
<td align="left">没有默认值</td>
<td align="left">proxy_cache_valid 200 304 2m; # 对于状态为200和304的缓存文件，缓存时间是2分钟</td>
<td align="left">http, server, location</td>
</tr>
<tr>
<td align="left">proxy_cache_key</td>
<td align="left">设置缓存文件的 key</td>
<td align="left">proxy_cache_key string;</td>
<td align="left">proxy_cache_key proxy_host$request_uri;</td>
<td align="left">proxy_cache_key “request_uri $cookie_user”; # 使用host +请求的uri以及cookie拼接成缓存key</td>
<td align="left">http, server, location</td>
</tr>
<tr>
<td align="left">proxy_cache_path</td>
<td align="left">指定缓存存储的路径，文件名为cache key的md5值，然后多级目录的话，根据level参数来生成，key_zone参数用来指定在共享内存中缓存数据的名称和内存大小，比如keys_zone&#x3D;mycache:100m，inactive用来指定缓存没有被访问后超时移除的时间，默认是10分钟，也可以自己指定比如inactive&#x3D;2h ；max_size 用来指定缓存的最大值，超过这个值则会自动移除最近最少使用（lru淘汰算法）的缓存 这个指令对应的参数很多，具体见官网：proxy_cache_path</td>
<td align="left">proxy_cache_path path [levels&#x3D;levels] [use_temp_path&#x3D;on|off] keys_zone&#x3D;name:size [inactive&#x3D;time] [max_size&#x3D;size] [min_free&#x3D;size] [manager_files&#x3D;number] [manager_sleep&#x3D;time] [manager_threshold&#x3D;time] [loader_files&#x3D;number] [loader_sleep&#x3D;time] [loader_threshold&#x3D;time] [purger&#x3D;on|off] [purger_files&#x3D;number] [purger_sleep&#x3D;time] [purger_threshold&#x3D;time];</td>
<td align="left">无</td>
<td align="left">proxy_cache_path &#x2F;data&#x2F;nginx&#x2F;cache levels&#x3D;1:2 keys_zone&#x3D;mycache:128m inactive&#x3D;3d max_size&#x3D;2g; # 设置缓存存放的目录为&#x2F;data&#x2F;nginx&#x2F;cache，并设置缓存名称为mycache，大小为128m， 三天未被访问过的缓存将自动清除，磁盘中缓存的最大容量为2GB。</td>
<td align="left">http</td>
</tr>
<tr>
<td align="left">proxy_cache_bypass</td>
<td align="left">定义不从缓存中获取响应数据的条件。如果字符串参数中至少有一个值不为空且不等于” 0 “，则不会从缓存中获取响应:</td>
<td align="left">proxy_cache_bypass string …;</td>
<td align="left">没有默认值</td>
<td align="left">proxy_cache_bypass arg_nocache$arg_comment;</td>
<td align="left">http, server, location</td>
</tr>
<tr>
<td align="left">proxy_cache_min_uses</td>
<td align="left">指定某一个相同请求在几次请求之后才缓存响应内容</td>
<td align="left">proxy_cache_min_uses number;</td>
<td align="left">proxy_cache_min_uses 1;</td>
<td align="left">proxy_cache_min_uses 3; 规定某一个请求在第3次之后才走nginx缓存</td>
<td align="left">http, server, location</td>
</tr>
<tr>
<td align="left">proxy_cache_use_stale</td>
<td align="left">指定后端服务器在返回什么状态码的情况下可以使用过期的缓存</td>
<td align="left">proxy_cache_use_stale error timeout invalid_header http_500 http_502 http_503 … |off ;</td>
<td align="left">proxy_cache_use_stale off;</td>
<td align="left">proxy_cache_use_stale error timeout http_500 http_502 http_503 http_504; # 规定服务在出现error timeout,以及502,503,504时可使用过期缓存</td>
<td align="left">http, server, location</td>
</tr>
<tr>
<td align="left">proxy_cache_lock</td>
<td align="left">默认不开启，开启后若出现并发重复请求，nginx只让一个请求去后端读数据，其他的排队并尝试从缓存中读取;</td>
<td align="left">proxy_cache_lock on |off;</td>
<td align="left">proxy_cache_lock off;</td>
<td align="left">proxy_cache_lock on; # 开启缓存锁</td>
<td align="left">http, server, location</td>
</tr>
<tr>
<td align="left">proxy_cache_lock_timeout</td>
<td align="left">等待缓存锁(proxy_cache_lock)超时之后将直接请求后端，且结果不会被缓存</td>
<td align="left">proxy_cache_lock_timeout time;</td>
<td align="left">proxy_cache_lock_timeout 5s;</td>
<td align="left">proxy_cache_lock_timeout 6s; # 等待缓存锁超时（6ms）之后将直接请求后端，结果不会被缓存。</td>
<td align="left">http, server, location</td>
</tr>
<tr>
<td align="left">proxy_cache_methods</td>
<td align="left">如果客户端请求方法在该指令中，则响应将被缓存。“GET”和“HEAD”方法总是被添加到列表中，尽管建议显式地指定它</td>
<td align="left">proxy_cache_methods GET|HEAD |POST …;</td>
<td align="left">proxy_cache_methods GET HEAD;</td>
<td align="left">proxy_cache_methods GET HEAD PUT POST; # 规定 可缓存的方法有 ：get head put post</td>
<td align="left">http, server, location</td>
</tr>
<tr>
<td align="left">…………..</td>
<td align="left">……….</td>
<td align="left">……….</td>
<td align="left">……….</td>
<td align="left">……….</td>
<td align="left">……….</td>
</tr>
</tbody></table>
<p>事实上，<strong>「ngx_http_proxy_module」</strong>模块中<strong>「代理缓存proxy_cache相关的指令远不止这些」</strong>，在这里我不可能把所有都列出来，只列出上边那几个已经很占篇幅了，如果有需要请参考： nginx官方文档， 在官方文档中，详细描述了ngx_http_proxy_module模块（包含了proxy_cache部分）的各种指令、作用以及使用方式，相信在遇到困难和疑惑时，官方文档永远是你最好的老师！如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068331.png" alt="图片"></p>
<h2 id="10-2、nginx缓存使用与效果演示"><a href="#10-2、nginx缓存使用与效果演示" class="headerlink" title="10.2、nginx缓存使用与效果演示"></a>10.2、nginx缓存使用与效果演示</h2><p><strong>「首先我们想要的效果是：」</strong> 将 <strong>「url+参数一样」</strong> 的请求的结果，缓存到nginx。</p>
<p>接下来我们修改下nginx.conf文件,如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    ...</span><br><span class="line">    # 指定缓存存放目录为/usr/local/nginx/test/nginx_cache_storage，并设置缓存名称为mycache，大小为64m， 1天未被访问过的缓存将自动清除，磁盘中缓存的最大容量为1gb</span><br><span class="line">    proxy_cache_path /usr/local/nginx/test/nginx_cache_storage levels=1:2 keys_zone=mycache:64m inactive=1d max_size=1g;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    server&#123;</span><br><span class="line">        ...</span><br><span class="line">        #  指定 username 参数中只要有字母 就不走nginx缓存  </span><br><span class="line">        if ($arg_username ~ [a-z]) &#123;</span><br><span class="line">             set $cache_name &quot;no cache&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location  /interface &#123;</span><br><span class="line">                   proxy_pass http://mybackendserver/;</span><br><span class="line">                   # 使用名为 mycache 的缓存空间</span><br><span class="line">                   proxy_cache mycache;</span><br><span class="line">                   # 对于200 206 状态码的数据缓存2分钟</span><br><span class="line">                   proxy_cache_valid 200 206 1m;</span><br><span class="line">                   # 定义生成缓存键的规则（请求的url+参数作为缓存key）</span><br><span class="line">                   proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">                   # 资源至少被重复访问2次后再加入缓存</span><br><span class="line">                   proxy_cache_min_uses 3;</span><br><span class="line">                   # 出现重复请求时，只让其中一个去后端读数据，其他的从缓存中读取</span><br><span class="line">                   proxy_cache_lock on;</span><br><span class="line">                   # 上面的锁 超时时间为4s，超过4s未获取数据，其他请求直接去后端</span><br><span class="line">                   proxy_cache_lock_timeout 4s;</span><br><span class="line">                   # 对于请求参数中有字母的 不走nginx缓存</span><br><span class="line">                   proxy_no_cache $cache_name; # 判断该变量是否有值，如果有值则不进行缓存，没有值则进行缓存</span><br><span class="line">                   # 在响应头中添加一个缓存是否命中的状态（便于调试）</span><br><span class="line">                   add_header Cache-status $upstream_cache_status;    </span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)image.png</p>
<p>ps: 在上边配置文件中除了缓存相关的配置，我们还加了一个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_header Cache-status $upstream_cache_status;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>❝</p>
<p>这个参数可以方便从响应头看到是否命中了nginx缓存，方便我们观察，其不同的值有不同的含义，upstream_cache_status的值集合如下：</p>
<p>MISS：请求未命中缓存<br>HIT：请求命中缓存。<br>EXPIRED：请求命中缓存但缓存已过期。<br>STALE：请求命中了陈旧缓存。<br>REVALIDDATED：Nginx验证陈旧缓存依然有效。<br>UPDATING：命中的缓存内容陈旧，但正在更新缓存。<br>BYPASS：响应结果是从原始服务器获取的。</p>
<p>❞</p>
</blockquote>
<p>nginx.conf文件配好后，在请求之前先看下数据库 “hzznb” 和 “张无忌” 都是存在的，如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<p>接下来我们<code>分别查询 张无忌 和 hzznb</code> 来看看缓存命中情况：</p>
<p>查询usernam&#x3D;<code>张无忌；</code> 第一次（未命中，因为此 url+参数 之前没请求过缓存中确实没有）：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)第二次也未命中就不截图了</p>
<p>第三次（未命中）：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)第四次（<strong>「命中」</strong>）：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<p>查询usernam&#x3D;<code>hzznb；</code> 第一次(未命中)：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)第2,3次也都是miss 即未命中（截图略）</p>
<p>第四次：（仍然是未命中，说明我们在nginx.conf中配置的规则：”参数中带字母则不缓存“ 生效了！）：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h1 id="11、黑白名单"><a href="#11、黑白名单" class="headerlink" title="11、黑白名单"></a>11、黑白名单</h1><p>nginx黑白名单比较简单，allow后配置你的白名单，deny后配置你的黑名单，在实际使用中，我们一般都是建个黑名单和白名单的文件然后再nginx.copnf中incluld一下，这样保持主配置文件整洁，也好管理。下边我为了方便就直接在主配置写了。</p>
<h2 id="11-1、语法作用域"><a href="#11-1、语法作用域" class="headerlink" title="11.1、语法作用域"></a>11.1、语法作用域</h2><p>关于黑白名单的语法和作用，我们直接看下官网的示例：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068332.png" alt="图片">可以看到ip 可以是ipv4 也可以是ipv6 也可以按照网段来配置，当然ip黑白配置可以在 http，server，location和limit_except这几个域都可以区别只是作用粒度大小问题。当然nginx建议我们使用 ngx_http_geo_module这个库，ngx_http_geo_module库支持 按地区、国家进行屏蔽，并且提供了IP库，当需要配置的名单比较多或者根据地区国家屏蔽时这个库可以帮上大忙。</p>
<p>下面我们配置并演示一下：</p>
<h2 id="11-2、黑白名单演示"><a href="#11-2、黑白名单演示" class="headerlink" title="11.2、黑白名单演示"></a>11.2、黑白名单演示</h2><p><strong>「允许任何ip访问前端，然后禁止172.30.128.64访问后端」</strong>，nginx.conf文件如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068333.png" alt="图片">访问前端，走&#x2F;page这个location（可以访问成功）：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)访问后端，走interface这个location（显示403被禁止了）：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h1 id="12、nginx限流"><a href="#12、nginx限流" class="headerlink" title="12、nginx限流"></a>12、nginx限流</h1><p>Nginx主要有两种限流方式：按并发连接数限流(ngx_http_limit_conn_module)、按请求速率限流(ngx_http_limit_req_module 使用的令牌桶算法)。</p>
<p>关于  ngx_http_limit_req_module模块，里边有很多种限流指令，官网资料一览：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)我们下面使用 ngx_http_limit_req_module 模块中的limit_req_zone和 limit_req 这两个指令来达到限制单个IP的<strong>「请求速率」</strong> 的目的。</p>
<h2 id="12-1、nginx限流配置解释"><a href="#12-1、nginx限流配置解释" class="headerlink" title="12.1、nginx限流配置解释"></a>12.1、nginx限流配置解释</h2><p>在 nginx.conf 中添加限流配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    ...</span><br><span class="line">    # 对请求速率限流</span><br><span class="line">    limit_req_zone $binary_remote_addr zone=myRateLimit:10m rate=5r/s;</span><br><span class="line">    </span><br><span class="line">    server&#123;</span><br><span class="line">        location /interface&#123;</span><br><span class="line">            ...</span><br><span class="line">            limit_req zone=myRateLimit burst=5  nodelay;</span><br><span class="line">            limit_req_status 520;</span><br><span class="line">            limit_req_log_level info;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068334.png" alt="图片">对上图标红的配置做个解释：</p>
<p><strong>「$binary_remote_addr」</strong>：表示基于 remote_addr(客户端IP) 来做限流<strong>「zone&#x3D;myRateLimit:10m」</strong>：表示使用myRateLimit来作为内存区域（存储访问信息）的名字，大小为10M，1M能存储16000 IP地址的访问信息，10M可以存储16W IP地址访问信息<strong>「rate&#x3D;5r&#x2F;s」</strong>：表示相同ip每秒最多请求5次，nginx是精确到毫秒的，也就是说此配置代表每200毫秒处理一个请求，这意味着自上一个请求处理完后，若后续200毫秒内又有请求到达，将拒绝处理该请求（如果没配burst的话）<br><strong>「burst&#x3D;5」</strong>：(英文 爆发 的意思)，意思是设置一个大小为5的缓冲队列，若同时有6个请求到达，Nginx 会处理第一个请求，剩余5个请求将放入队列，然后每隔200ms从队列中获取一个请求进行处理。若请求数大于6，将拒绝处理多余的请求，直接返回503<br><strong>「nodelay」</strong>：针对的是 burst 参数，burst&#x3D;5 nodelay 这个配置表示被放到缓冲队列的这5个请求会立马处理，不再是每隔200ms取一个了。但是值得注意的是，即使这5个突发请求立马处理并结束，后续来了请求也不一定不会立马处理，因为虽然请求被处理了但是请求所占的坑并不会被立即释放，而是只能按 200ms 一个来释放，释放一个后 才将等待的请求 入队一个。<br><strong>「另外两个：」</strong> limit_req_status&#x3D;520表示当被限流后，nginx的返回码，limit_req_log_level info代表日志级别</p>
<p><strong>「注意：」</strong> 如果不开启nodelay且开启了burst这个配置，那么将会严重影响用户体验（你想想假设burst队列长度为100的话每100ms处理一个,那队列最后那个请求得等10000ms&#x3D;10s后才能被处理，那不超时才怪呢此时burst已经意义不大了）所以一般情况下 建议burst和nodelay结合使用，从而尽可能达到速率稳定，但突然流量也能正常处理的效果。</p>
<h2 id="12-2、nginx限流（针对请求速率）"><a href="#12-2、nginx限流（针对请求速率）" class="headerlink" title="12.2、nginx限流（针对请求速率）"></a>12.2、nginx限流（针对请求速率）</h2><p>为了突出burst和nodealy的作用，我们一步一步演示</p>
<h3 id="12-2-1、限制每秒同一ip最多访问5次-1s"><a href="#12-2-1、限制每秒同一ip最多访问5次-1s" class="headerlink" title="12.2.1、限制每秒同一ip最多访问5次&#x2F;1s"></a>12.2.1、限制每秒同一ip最多访问5次&#x2F;1s</h3><p>修改nginx.conf，把burst&#x3D;5 nodelay注释掉，如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)上边的配置意味着每秒最多处理5次同样ip的请求，我们使用jmeter设置1个线程循环10次，间隔时间为100ms,效果如下（5成功5失败）：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)如果我们将间隔时间改200的话，是都可以成功的，因为一秒最多5次精确到毫秒其实就是最多200ms一次,而200ms一次正好没超过我们配置的 5r&#x2F;s 的速率：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)运行jemeter发现间隔200ms访问一次的请求都成功了：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h3 id="12-2-2、打开burst参数并设置成5"><a href="#12-2-2、打开burst参数并设置成5" class="headerlink" title="12.2.2、打开burst参数并设置成5"></a>12.2.2、打开burst参数并设置成5</h3><p>现在我们的速率不变还是最多5次一秒，但是设置burst&#x3D;5代表缓冲队列的长度为5，nginx每隔200ms，从缓冲队列拿一个进行处理，配置如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068435.png" alt="图片"></p>
<p>之后我们配置线程数量为15，每隔100ms掉一次，效果如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068436.png" alt="图片">可以看到共计6个请求被处理，第一个是被nginx进程直接处理，之后往burst塞了5个（每隔200ms拿一个进行处理）剩下的都被返回了520状态码代表被拒绝了，我们找一个（1-10这个）被拒的看看状态码：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068437.png" alt="图片"></p>
<h3 id="12-2-3、打开nodelay"><a href="#12-2-3、打开nodelay" class="headerlink" title="12.2.3、打开nodelay"></a>12.2.3、打开nodelay</h3><p>我们上边说过<strong>「打开nodlay的话」</strong>，代表放到burst队列的请求直接处理 ，<strong>「不再按速率 200ms&#x2F;次 拿了」</strong>，配置如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)接下来我们还是配置15个线程，然后每个线程间隔100ms请求一次，看下效果：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)可以很明显的看到：开启nodelay后响应时间10几秒明显比不开启nodelay快很多，但是请求成功的还是6个，因为就像我们上边说的ngdelay虽然会即时处理，但是释放坑位是200ms释放一个 <strong>「<code>（也就是说即时开启了nodelay 但释放令牌的速度是不变的）</code>」</strong> ，所以nodelay参数本质上并没有提高访问速率，而仅仅是让处于burst队列的请求 <code>”被快速处理“</code> 罢了。</p>
<h2 id="12-3、nginx限流（针对连接数量）"><a href="#12-3、nginx限流（针对连接数量）" class="headerlink" title="12.3、nginx限流（针对连接数量）"></a>12.3、nginx限流（针对连接数量）</h2><p>针对连接数量的限流和速率不一样，即使你速率是1ms一次，只要你连接数量不超过设置的，那么也访问成功。如果连接数超过设置的值将会请求失败。值得注意的是他是 ngx_http_limit_conn_module模块中的，不要和 速率限流的 ngx_http_limit_req_module模块搞混了。</p>
<p>配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    # 针对ip  对请求连接数限流</span><br><span class="line">    ...</span><br><span class="line">    limit_conn_zone $binary_remote_addr zone=myConnLimit:10m; </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    server&#123;</span><br><span class="line">       ...</span><br><span class="line">       limit_conn myConnLimit 12;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068438.png" alt="图片">简单对以上标黄处说明一下，<code>limit_conn_zone $binary_remote_addr zone=myConnLimit:10m;</code>代表的意思 是 基于连接数量限流，限流的对象是ip 名称是myConnLimit 存储空间大小10mb（即存放某ip的访问记录），limit_conn myConnLimit 12;标识该ip最大支持12个连接超过则返回503（被限流后状态码默认是503，当然你也可以修改返回码 像上边的 针对请求速率限流 ，返回码就是 我修改的520）。</p>
<p>使用jmeter搞20个线程，0延迟，演示下效果：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068439.png" alt="图片">可以看到由于我们配置的并发数是12，所以20个连接中有8个都被限了。这个理解起来似乎比速率限流（ngx_http_limit_req_module）简单些我们就不过多解释了。</p>
<h1 id="13、https配置"><a href="#13、https配置" class="headerlink" title="13、https配置"></a>13、https配置</h1><p>说到https大家应该并不陌生，我这里不啰嗦介绍了。一般我们安装的nginx模块都是不包含ssl模块的，所以需要手动安装下。安装完之后我们再说如何配置https。</p>
<h2 id="13-1、https-ssl模块安装"><a href="#13-1、https-ssl模块安装" class="headerlink" title="13.1、https_ssl模块安装"></a>13.1、https_ssl模块安装</h2><p>首先我们使用 <code>nginx -V</code> (大写) 看下有没有安装https_ssl模块：</p>
<p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)可以看到我已经安装了,实际上我可以直接使用https_ssl模块了但是为了文章完善性。我下边说一下https_ssl模块的安装步骤：</p>
<blockquote>
<p>❝</p>
<p>注意：下边的https_ssl模块是安装到我的旧版本1.23.0去了，而我当前生效运行的nginx是1.24.0 ，使用<code>ps -ef | grep nginx</code> 命令可看出当前运行的nginx：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)下边的安装https_ssl仅仅是为了内容全面，<strong>「而不是真正使用1.23.0版本的nginx或者1.23.0版本的https_ssl模块」</strong>（本文使用的版本都是1.24.0 ，1.23.0是我之前的一个nginx版本）。</p>
<p>❞</p>
</blockquote>
<p>没有ssl模块情况下，首先我们<code>进入nginx解压目录</code>：我的是 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx-1.23.0&#x2F; <strong>「总之就是找到你的nginx解压目录」</strong>)  ，之后在该目录执行命令 <code>./configure --prefix=/usr/local/nginx --with-http_ssl_module</code> 来安装ssl模块，如下图：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)安装好后，在&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx-1.23.0&#x2F; 目录中执行 <code>make</code> 命令，重新编译nginx,注意此处无需make install，make成功后，我们执行 <code>cp ./objs/nginx /usr/local/nginx/sbin/</code> 命令将编译后的文件覆盖到 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;，之后执行 <code>/usr/local/nginx/sbin/nginx -V</code>，可看到ssl模块就安装成功了。操作记录图如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="13-2、域名购买-解析-ssl证书申请与验证"><a href="#13-2、域名购买-解析-ssl证书申请与验证" class="headerlink" title="13.2、域名购买&amp;解析&amp;ssl证书申请与验证"></a>13.2、域名购买&amp;解析&amp;ssl证书申请与验证</h2><p>要配置ssl最好是有个域名，所以我花一杯酱香拿铁的💰买了一个域名（在买域名前需要进行域名模板实名，具体操作去腾讯云官网看这里不啰嗦了），我买的域名是： <strong>「<code>hzznb-xzll.xyz</code>」</strong></p>
<p>ps： 如果我没记错的话这是我的第一个域名，虽然他10块钱但是我很珍惜他😄😄，接下来可以在我的域名中看到已经成功了。</p>
<p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)有域名了，下一步就需要配置DNS解析，让别人通过公网也访问到呀，所以点击上图的 <strong>「解析」</strong> 按钮后，来到下边的页面添加解析记录，如下：（主机记录www的结果是：<a target="_blank" rel="noopener" href="http://www.hzznb-xzll.xyz/">www.hzznb-xzll.xyz</a> ，@的结果是 hzznb-xzll.xyz， *的意思为泛解析，对应的结果是 xxx.hzznb-xzll.xyz）：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)配置好解析后，我们开始申请一个免费的ssl证书并将其和我上边的域名绑定，如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068440.png" alt="图片">提交申请后，因为我们选择的手动DNS验证，所以接下来按照人家的提示手动配置（这个操作比较重要，不做这一步，证书验证肯定过不去，所以必须做并且做对）：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068441.png" alt="图片">之后我们在我的证书看到已经完成验证，此时就可以下载ssl证书，然后配置我们的nginx了：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068442.png" alt="图片">因为我们接下来要配置到nginx反向代理服务器，所以这里选择下载nginx类型的ssl证书：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="13-3、上传并配置nginx以及演示"><a href="#13-3、上传并配置nginx以及演示" class="headerlink" title="13.3、上传并配置nginx以及演示"></a>13.3、上传并配置nginx以及演示</h2><p>下载到本地后是个zip我们解压之后会看到里边有4个文件分别是：</p>
<p>hzznb-xzll.xyz_bundle.crt 证书文件<br>hzznb-xzll.xyz_bundle.pem 证书文件（可忽略该文件）<br>hzznb-xzll.xyz.key 私钥文件<br>hzznb-xzll.xyz.csr CSR 文件 （CSR 文件是申请证书时由您上传或系统在线生成的，提供给 CA 机构。安装时可忽略该文件。）</p>
<p>之后我们仅需要把  hzznb-xzll.xyz.key 和 hzznb-xzll.xyz_bundle.crt 这俩货上传到我新建的 certificate文件夹：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;certificate&#x2F;  ，操作如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)上传完成：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)ssl证书准备好后，我们需要配置一个https的server（如下配置：）<br>下边的指令名称都有注释说明了各个指令是干啥的，我也就不啰嗦了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># --------------------HTTPS 配置---------------------</span><br><span class="line">    server &#123;</span><br><span class="line">        #SSL 默认访问端口号为 443</span><br><span class="line">        listen 443 ssl; </span><br><span class="line">        #填写绑定证书的域名 </span><br><span class="line">        server_name www.hzznb-xzll.xyz hzznb-xzll.xyz; </span><br><span class="line">        #请填写证书文件的相对路径或绝对路径</span><br><span class="line">        ssl_certificate /usr/local/nginx/certificate/hzznb-xzll.xyz_bundle.crt; </span><br><span class="line">        #请填写私钥文件的相对路径或绝对路径</span><br><span class="line">        ssl_certificate_key /usr/local/nginx/certificate/hzznb-xzll.xyz.key; </span><br><span class="line">        #停止通信时，加密会话的有效期，在该时间段内不需要重新交换密钥</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        #服务器支持的TLS版本</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; </span><br><span class="line">        #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; </span><br><span class="line">        #开启由服务器决定采用的密码套件</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure>

<p>可以看到我们上传到 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;certificate&#x2F;目录下的 .crt和.key文件被使用到了。</p>
<p>现在我们仅仅是配好一个https类型的server，光一个server没法访问也没意思，我们需要让给他配置上游服务以及路由规则，这里我们直接使用我们上边的 80端口那个server中的location配置，直接copy过来，<strong>「https server的配置」</strong> 如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068443.png" alt="图片">到这里，就可以通过https方式访问我们的页面和接口了。但是需要注意的是，由于我们的协议和域名换了，所以index_page.html里边的接口地址也得变了，如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068444.png" alt="图片">之后我们将index_page.html上传到nginx的 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;test&#x2F;static&#x2F; 目录，并重启nginx（nginx -s reload） 之后在浏览器访问试试，</p>
<blockquote>
<p>❝</p>
<p>注意：我最开始在配置dns解析时记录值配的是公网ip,但是我发现好像不好使，总是连接失败：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)，后来改成 局域网ip 172.30.128.65 发现可行了![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<p>❞</p>
</blockquote>
<p>修改云解析dns记录值为172.30.128.65后，访问效果如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)从上边可以看到，我们可以通过https方式访问前端页面和后台接口了。</p>
<h2 id="13-4、http跳转https"><a href="#13-4、http跳转https" class="headerlink" title="13.4、http跳转https"></a>13.4、http跳转https</h2><p>一般情况下为了安全都不使用http方式访问页面or后台服务，但是有的人就是喜欢使用http访问怎么办？好说，我给http加个跳转，你访问 <a target="_blank" rel="noopener" href="http://xxx.com/">http://xxx.com</a> 我给你跳转到<a target="_blank" rel="noopener" href="https://xxx.com/">https://xxx.com</a>,  想达到此效果需要先修改下nginx.conf文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_name www.hzznb-xzll.xyz hzznb-xzll.xyz;</span><br><span class="line"># 重定向到目标地址</span><br><span class="line">return 301 https://$server_name$request_uri;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068445.png" alt="图片">之后重启nginx看下演示效果：</p>
<p>首先请求 <a target="_blank" rel="noopener" href="http://www.hzznb-xzll.xyz/page/">http://www.hzznb-xzll.xyz/page/</a> 会返回重定向地址，让你重新定向到 <a target="_blank" rel="noopener" href="https://www.hzznb-xzll.xyz/page/![%E5%9B%BE%E7%89%87]">https://www.hzznb-xzll.xyz/page/![图片]</a>(data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)请求（这一步浏览器会自动发起请求，无需手动点击或刷新啥的）定向后的目标地址： <a target="_blank" rel="noopener" href="https://www.hzznb-xzll.xyz/page/![%E5%9B%BE%E7%89%87]">https://www.hzznb-xzll.xyz/page/![图片]</a>(data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)可以看到http方式的请求被成功重定向到了https server(443端口对应的server)。</p>
<h1 id="14、压缩"><a href="#14、压缩" class="headerlink" title="14、压缩"></a>14、压缩</h1><p>压缩功能比较实用尤其是处理一些大文件时，而gzip 是规定的三种标准 HTTP 压缩格式之一。目前绝大多数的网站都在使用 gzip 传输 HTML 、CSS 、 JavaScript 等资源文件。需要知道的是，并不是每个浏览器都支持 gzip 压缩，如何知道客户端（浏览器）是否支持 压缩 呢？ 可以通过观察 某请求头中的 Accept-Encoding 来观察是否支持压缩，另外只有客户端支持也不顶事，服务端得返回gzip格式的文件呀，那么这件事nginx可以帮我们做，我们可以通过 Nginx 的配置来让服务端支持 gzip。服务端返回压缩文件后浏览器进行解压缩从而展示正常内容。</p>
<h2 id="14-1、压缩前"><a href="#14-1、压缩前" class="headerlink" title="14.1、压缩前"></a>14.1、压缩前</h2><p>首先应该明确的是我当前是没开启压缩的：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<p>其次为了方便看出效果，我们先将之前那个index_page.html文件加点图片，加点文字给他的文件大小弄大点，如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)这里无需重启nginx，看下<strong>「没开启压缩」</strong> 时候的效果：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="14-2、压缩后"><a href="#14-2、压缩后" class="headerlink" title="14.2、压缩后"></a>14.2、压缩后</h2><p>想要压缩就得配置nginx,我们修改nginx.conf文件，在http指令块添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    # 开启/关闭 压缩机制</span><br><span class="line">    gzip on;</span><br><span class="line">    # 根据文件类型选择 是否开启压缩机制</span><br><span class="line">    gzip_types text/plain application/javascript text/css application/xml text/javascript image/jpeg image/jpg image/gif image/png  application/json;</span><br><span class="line">    # 设置压缩级别，一共9个级别  1-9   ，越高资源消耗越大 越耗时，但压缩效果越好，</span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    # 设置是否携带Vary:Accept-Encoding 的响应头</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    # 处理压缩请求的 缓冲区数量和大小</span><br><span class="line">    gzip_buffers 32 64k;</span><br><span class="line">    # 对于不支持压缩功能的客户端请求 不开启压缩机制</span><br><span class="line">    gzip_disable &quot;MSIE [1-6]\.&quot;; # 比如低版本的IE浏览器不支持压缩</span><br><span class="line">    # 设置压缩功能所支持的HTTP最低版本</span><br><span class="line">    gzip_http_version 1.1;</span><br><span class="line">    # 设置触发压缩的最小阈值</span><br><span class="line">    gzip_min_length 2k;</span><br><span class="line">    # off/any/expired/no-cache/no-store/private/no_last_modified/no_etag/auth 根据不同配置对后端服务器的响应结果进行压缩</span><br><span class="line">    gzip_proxied any;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>几个指令的作用在注释中写明了这里不再过多解释。接下来我们重启nginx，然后看下压缩前后的效果：</p>
<p>html文件压缩：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)接口响应压缩：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)可以看到不管是html还是接口响应数据， 压缩后的体积变得非常小了，压缩的效果还是不错的，但是值得注意的是压缩后虽然体积变小了，但是响应的时间会变长，因为压缩&#x2F;解压也需要时间呀！压缩功能似乎有点：<strong>「用时间换空间的感觉！」</strong>，当然压缩级别可以调的，你可以选择较低级别的压缩，这样既能实现压缩功能使得数据包体积降下来，同时压缩时间也会缩短是比较折中的一种方案（我在演示时为了效果，配置的压缩级别是9 ，一共9个级别， 9是最高级别的压缩等级）。</p>
<h1 id="15、其他一些比较常用的指令与说明"><a href="#15、其他一些比较常用的指令与说明" class="headerlink" title="15、其他一些比较常用的指令与说明"></a>15、其他一些比较常用的指令与说明</h1><p>关于nginx的指令其实太多了，有些常用的指令不说一下的话，有时候遇见了不懂啥意思，所以这里说一下nginx几个比较常用的指令（上边nginx.conf文件解读 以及某些小节中已经说了很多指令了，这里也不管重不重复吧，说明几个我觉得有必要讲的几个）</p>
<h2 id="15-1、rewrite"><a href="#15-1、rewrite" class="headerlink" title="15.1、rewrite"></a>15.1、rewrite</h2><p>rewrite指令是通过正则表达式来改变URI。可以同时存在一个或多个指令。需要按照顺序依次对URL进行匹配和处理，常用于重定向功能。</p>
<p>rewrite语法如下：</p>
<table>
<thead>
<tr>
<th align="left">语法:</th>
<th align="left"><code>rewrite 正则表达式 要替换的内容 [flag];</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left">默认:</td>
<td align="left">—</td>
</tr>
<tr>
<td align="left">作用域:</td>
<td align="left"><code>server</code>, <code>location</code>, <code>if</code></td>
</tr>
</tbody></table>
<p>其中flag有如下几个值：</p>
<p><strong>「last:」</strong> 本条规则匹配完成后，继续向下匹配新的location URI 规则。<br><strong>「break:」</strong> 本条规则匹配完成即终止，不再匹配后面的任何规则。<br><strong>「redirect:」</strong> 返回302临时重定向，浏览器地址会显示跳转新的URL地址。<br><strong>「permanent:」</strong> 返回301永久重定向。浏览器地址会显示跳转新的URL地址。</p>
<p>下边我们演示下四种重写的效果 首先修改nginx.conf文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    server_name www.hzznb-xzll.xyz hzznb-xzll.xyz;</span><br><span class="line"></span><br><span class="line">    # 临时（redirect）重定向配置</span><br><span class="line">    location /temp_redir &#123;</span><br><span class="line">        rewrite ^/(.*) https://www.baidu.com redirect;</span><br><span class="line">    &#125;</span><br><span class="line">    # 永久重定向（permanent）配置</span><br><span class="line">    location /forever_redir &#123;</span><br><span class="line"></span><br><span class="line">        rewrite ^/(.*) https://www.baidu.com permanent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # rewrite last配置</span><br><span class="line">    location /1 &#123;</span><br><span class="line">      rewrite /1/(.*) /2/$1 last;</span><br><span class="line">    &#125;</span><br><span class="line">    location /2 &#123;</span><br><span class="line">      rewrite /2/(.*) /3/$1 last;</span><br><span class="line">    &#125;</span><br><span class="line">    location /3 &#123;</span><br><span class="line">      alias  &#x27;/usr/local/nginx/test/static/&#x27;;</span><br><span class="line">      index location_last_test.html;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)image.png</p>
<p><strong>「last配置:」</strong> 可以看到我们定义 访问 <a target="_blank" rel="noopener" href="http://hzznb-xzll.xyz/1/">http://hzznb-xzll.xyz/1/</a> 的请求被替换为 <a target="_blank" rel="noopener" href="http://hzznb-xzll.xyz/2/">http://hzznb-xzll.xyz/2/</a> 之后再被替换为 <a target="_blank" rel="noopener" href="http://hzznb-xzll.xyz/3/">http://hzznb-xzll.xyz/3/</a>  最后找到&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;test&#x2F;static&#x2F;location_last_test.html 这个文件并返回。<br><strong>「redirect配置：」</strong> 当访问 <a target="_blank" rel="noopener" href="http://hzznb-xzll.xyz/temp_redir/">http://hzznb-xzll.xyz/temp_redir/</a> 这个请求会临时（302）重定向到百度页面<br><strong>「permanent配置：」</strong> 当访问 <a target="_blank" rel="noopener" href="http://hzznb-xzll.xyz/forever_redir/">http://hzznb-xzll.xyz/forever_redir/</a> 这个请求会永久（301）重定向到百度页面</p>
<p>效果如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="15-2、if"><a href="#15-2、if" class="headerlink" title="15.2、if"></a>15.2、if</h2><p>该指令用于条件判断，并且根据条件判断结果来选择不同的配置，其作用于为：server&#x2F;location 块。这个指令比较简单，因为编程中if语句都是非常高频使用的，但是里边怎么写 就得说说nginx的全局变量了，因为我们很多时候，都是在对 比如：url  参数 ip 域名等等做比对或者判断（一般都使用正则的方式）,而这些都在nginx全局变量中可以拿到，比如下边这个if判断就用到了全局变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指定 username 参数中只要有字母 就不走nginx缓存</span><br><span class="line">if ($arg_username ~ [a-z]) &#123;</span><br><span class="line">    set $cache_name &quot;no cache&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正则表达式就不多说了，具体使用时查一下，我们下边列一下nginx的全局变量：</p>
<h2 id="15-3、nginx全局变量"><a href="#15-3、nginx全局变量" class="headerlink" title="15.3、nginx全局变量"></a>15.3、nginx全局变量</h2><table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$time_local</td>
<td align="left">本地时间</td>
</tr>
<tr>
<td align="left">$time_iso8601</td>
<td align="left">ISO 8601 时间格式</td>
</tr>
<tr>
<td align="left">$arg_name</td>
<td align="left">请求中的的参数名，即“?”后面的arg_name&#x3D;arg_value形式的arg_name</td>
</tr>
<tr>
<td align="left">$args</td>
<td align="left">与$query_string相同 等于URL当中的参数(GET请求时)，如a&#x3D;1&amp;b&#x3D;2</td>
</tr>
<tr>
<td align="left">$document_uri</td>
<td align="left">与相同这个变量指当前的请求，不包括任何参数见args)</td>
</tr>
<tr>
<td align="left">$request_uri</td>
<td align="left">包含请求参数的原始URI，不包含主机名，如：&#x2F;aaa&#x2F;bbb.html?a&#x3D;1&amp;b&#x3D;2</td>
</tr>
<tr>
<td align="left">$is_args</td>
<td align="left">如果URL包含参数则为？，否则为空字符串</td>
</tr>
<tr>
<td align="left">$query_string</td>
<td align="left">与$args相同 等于URL当中的参数(GET请求时)，如a&#x3D;1&amp;b&#x3D;2</td>
</tr>
<tr>
<td align="left">$uri</td>
<td align="left">当前请求的URI,不包含任何参数</td>
</tr>
<tr>
<td align="left">$remote_addr</td>
<td align="left">获取客户端ip</td>
</tr>
<tr>
<td align="left">$binary_remote_addr</td>
<td align="left">客户端ip（二进制)</td>
</tr>
<tr>
<td align="left">$remote_port</td>
<td align="left">客户端port</td>
</tr>
<tr>
<td align="left">$remote_user</td>
<td align="left">用于基本验证的用户名。</td>
</tr>
<tr>
<td align="left">$host</td>
<td align="left">请求主机头字段，否则为服务器名称，如:<a target="_blank" rel="noopener" href="https://www.hzznb-xzll.xyz/">https://www.hzznb-xzll.xyz</a></td>
</tr>
<tr>
<td align="left">$proxy_host</td>
<td align="left">proxy_pass 指令设置的后端服务器的域名（或者IP地址）</td>
</tr>
<tr>
<td align="left">$proxy_port</td>
<td align="left">proxy_pass 指令设置的后端服务器的监听端口。</td>
</tr>
<tr>
<td align="left">$http_host</td>
<td align="left">是和server_port 两个变量的结合</td>
</tr>
<tr>
<td align="left">$request</td>
<td align="left">用户请求信息，如：GET ?a&#x3D;1&amp;b&#x3D;2 HTTP&#x2F;1.1</td>
</tr>
<tr>
<td align="left">$request_time</td>
<td align="left">请求所用时间，单位毫秒</td>
</tr>
<tr>
<td align="left">$request_method</td>
<td align="left">请求的方法 比如 get post put delete update 等</td>
</tr>
<tr>
<td align="left">$request_filename</td>
<td align="left">当前请求的文件的路径名，由root或alias和URI request组合而成,如：&#x2F;aaa&#x2F;bbb.html</td>
</tr>
<tr>
<td align="left">$status</td>
<td align="left">请求的响应状态码,如：200</td>
</tr>
<tr>
<td align="left">$body_bytes_sent</td>
<td align="left">响应时送出的body字节数数量。即使连接中断，这个数据也是精确的,如：40，传输给客户端的字节数，响应头不计算在内；这个变量和Apache的mod_log_config模块中的“%B”参数保持兼容</td>
</tr>
<tr>
<td align="left">$content_length</td>
<td align="left">等于请求行的“Content_Length”的值</td>
</tr>
<tr>
<td align="left">$content_type</td>
<td align="left">等于请求行的“Content_Type”的值</td>
</tr>
<tr>
<td align="left">$http_referer</td>
<td align="left">引用地址</td>
</tr>
<tr>
<td align="left">$http_user_agent</td>
<td align="left">客户端agent信息,如：Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;119.0.0.0 Safari&#x2F;537.36 这个可以用来区分手机端还是pc端</td>
</tr>
<tr>
<td align="left">$document_root</td>
<td align="left">针对当前请求的根路径设置值</td>
</tr>
<tr>
<td align="left">$hostname</td>
<td align="left">主机名称</td>
</tr>
<tr>
<td align="left">$http_cookie</td>
<td align="left">客户端cookie信息</td>
</tr>
<tr>
<td align="left">$cookie_COOKIE</td>
<td align="left">cookie COOKIE变量的值</td>
</tr>
<tr>
<td align="left">$limit_rate</td>
<td align="left">这个变量可以限制连接速率，0表示不限速</td>
</tr>
<tr>
<td align="left">$request_body</td>
<td align="left">记录POST过来的数据信息</td>
</tr>
<tr>
<td align="left">$request_body_file</td>
<td align="left">客户端请求主体信息的临时文件名</td>
</tr>
<tr>
<td align="left">$scheme</td>
<td align="left">HTTP方法（如http，https）</td>
</tr>
<tr>
<td align="left">$request_completion</td>
<td align="left">如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)，如：OK</td>
</tr>
<tr>
<td align="left">$server_protocol</td>
<td align="left">请求使用的协议，通常是HTTP&#x2F;1.0或HTTP&#x2F;1.1，如：HTTP&#x2F;1.1</td>
</tr>
<tr>
<td align="left">$server_addr</td>
<td align="left">服务器IP地址，在完成一次系统调用后可以确定这个值</td>
</tr>
<tr>
<td align="left">$server_name</td>
<td align="left">响应请求的服务器名称</td>
</tr>
<tr>
<td align="left">$server_port</td>
<td align="left">请求到达服务器的端口号，如：80</td>
</tr>
<tr>
<td align="left">$connection</td>
<td align="left">连接序列号</td>
</tr>
<tr>
<td align="left">$connection_requests</td>
<td align="left">当前通过连接发出的请求数</td>
</tr>
<tr>
<td align="left">$nginx_version</td>
<td align="left">nginx版本</td>
</tr>
<tr>
<td align="left">$pid</td>
<td align="left">工作进程的PID</td>
</tr>
<tr>
<td align="left">$pipe</td>
<td align="left">如果请求来自管道通信，值为“p”，否则为“.”</td>
</tr>
<tr>
<td align="left">$proxy_protocol_addr</td>
<td align="left">获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串</td>
</tr>
<tr>
<td align="left">$realpath_root</td>
<td align="left">对应于当前请求的根目录或别名值的绝对路径名，所有符号连接都解析为真实路径。</td>
</tr>
</tbody></table>
<p>可以看到全局变量比较多，但是没关系在使用时再去详查就好了。</p>
<h2 id="15-4、auto-index"><a href="#15-4、auto-index" class="headerlink" title="15.4、auto_index"></a>15.4、auto_index</h2><p>一般用于快速搭建静态资源网站，比如我要给自己搞个书籍网站里边放些好书，以便需要时查看阅读，首先建一个book文件夹并往里放几本书：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<p>之后我们配置nginx， 使得访问 <a target="_blank" rel="noopener" href="http://hzznb-xzll.xyz/book/">http://hzznb-xzll.xyz/book/</a> 时,返回 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;test&#x2F;book&#x2F;目录下的书籍，配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /book/ &#123;</span><br><span class="line">    root /usr/local/nginx/test;</span><br><span class="line">    autoindex on; # 打开 autoindex，，可选参数有 on | off</span><br><span class="line">    autoindex_format html; # 以html的方式进行格式化，可选参数有 html | json | xml</span><br><span class="line">    autoindex_exact_size on; # 修改为off，会以KB、MB、GB显示文件大小，默认为on以bytes显示出⽂件的确切⼤⼩</span><br><span class="line">    autoindex_localtime off; # 显示⽂件时间 GMT格式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)image.png</p>
<p>重启nginx并在浏览器输入  <a target="_blank" rel="noopener" href="http://hzznb-xzll.xyz/book/">http://hzznb-xzll.xyz/book/</a> （注意book后边的斜线 &#x2F; 不能去掉，否则404了，具体原因我们下边马上会说），看下效果：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h2 id="15-5、root-alias"><a href="#15-5、root-alias" class="headerlink" title="15.5、root&amp;alias"></a>15.5、root&amp;alias</h2><p>root和alias这俩货一般都是用于指定静态资源目录，但是还是有挺大区别的，虽然这是个小知识点但是如果你不清楚规则，很容易走弯路，所以这里阐明并演示这俩的区别。</p>
<h3 id="15-5-1、root"><a href="#15-5-1、root" class="headerlink" title="15.5.1、root"></a>15.5.1、root</h3><p>说先说root：</p>
<table>
<thead>
<tr>
<th align="left">语法:</th>
<th align="left"><code>root path;</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left">默认值:</td>
<td align="left"><code>root html;</code></td>
</tr>
<tr>
<td align="left">作用域:</td>
<td align="left"><code>http</code>, <code>server</code>, <code>location</code>, <code>if in location</code></td>
</tr>
</tbody></table>
<p>为请求设置根目录。例如，使用以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /static/ &#123;</span><br><span class="line">    root /usr/local/nginx/test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，当你请求 <a target="_blank" rel="noopener" href="http://www.hzznb-xzll.xyz/static/image2.jpg">http://www.hzznb-xzll.xyz/static/image2.jpg</a> 时，&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;test&#x2F;static&#x2F;image2.jpg  文件将被作为响应内容响应给客户端,也就是说 :<br><strong>「root指令会 将 &#x2F;static&#x2F; 拼接到 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;test 后边<br>即完整目录路径为： &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;test&#x2F;static&#x2F;」</strong>演示效果如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)</p>
<h3 id="15-5-2、alias"><a href="#15-5-2、alias" class="headerlink" title="15.5.2、alias"></a>15.5.2、alias</h3><p><strong>「alias」</strong> 中文意思别名，这个和root最大区别就是 <strong>「不会进行拼接」</strong>，下边我们改下nginx.conf文件来演示下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /static &#123; # 注意一般 alias的 url都不带后边的/</span><br><span class="line">     alias /usr/local/nginx/test/; # 使用alias时  这里的目录最后边一定要加/ 否则就404</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068446.png" alt="图片">上边配置的意思就是当前你访问 <a target="_blank" rel="noopener" href="http://www.hzznb-xzll.xyz/static/image2.jpg">http://www.hzznb-xzll.xyz/static/image2.jpg</a> 时，nginx会去alias配置的路径：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;test&#x2F;目录下找 image2.jpg 这个文件从而返回。比如我现在的&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;test&#x2F;目录下没有image2.jpg 文件则返回404，如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068447.png" alt="图片">之后我们copy image2.jpg文件到 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;test&#x2F; 目录，然后看下效果：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068448.png" alt="图片">可以看到成功返回了。</p>
<h3 id="15-5-3、proxy-pass-中的斜线与root和-alias的相似之处"><a href="#15-5-3、proxy-pass-中的斜线与root和-alias的相似之处" class="headerlink" title="15.5.3、proxy_pass 中的斜线与root和 alias的相似之处"></a>15.5.3、proxy_pass 中的斜线与root和 alias的相似之处</h3><p>在我们上边的负载均衡以及动静锋利等等演示中，可以看到我们的proxy_pass的配置基本上都是这么配的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_pass http://mybackendserver/</span><br></pre></td></tr></table></figure>

<p>这里有个东西和root与alias的规则很像，所以我们在这里也提一下，就是 <a target="_blank" rel="noopener" href="http://mybackendserver/">http://mybackendserver/</a>  后边这个斜线 &#x2F;，如果你不写 &#x2F; 则会将location的url拼接到路径后边，如果你写了则不会，下边我们演示下这样更直观些。修改nginx.conf如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068449.png" alt="图片">interface 这个location不会拼接 interface到 <a target="_blank" rel="noopener" href="http://mybackendserver/">http://mybackendserver/</a>  后边，如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068450.png" alt="图片"></p>
<p>interface2 这个location <strong>「会拼接」</strong> interface2到 <a target="_blank" rel="noopener" href="http://mybackendserver/">http://mybackendserver/</a>  后边（从而导致接口404），如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/640-171595152068451.png" alt="图片"></p>
<p><strong>「看出来了吗，proxy_pass 值后边加斜线和不加斜线 ，区别是很大的。不加斜线 有点像root（会拼接），加了斜线 有点像alias （不会进行 拼接）。要牢记这个事情。」</strong></p>
<h2 id="15-6、upstream-中常用的几个指令"><a href="#15-6、upstream-中常用的几个指令" class="headerlink" title="15.6、upstream 中常用的几个指令"></a>15.6、upstream 中常用的几个指令</h2><p>在upstream中，有些指令也是比较常用的所以我们这里也列一下：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">server</td>
<td align="left">反向服务地址</td>
</tr>
<tr>
<td align="left">weight</td>
<td align="left">权重</td>
</tr>
<tr>
<td align="left">fail_timeout</td>
<td align="left">与max_fails结合使用。</td>
</tr>
<tr>
<td align="left">max_fails</td>
<td align="left">设置在fail_timeout参数设置的时间内最大失败次数，如果在这个时间内，所有针对该服务器的请求都失败了，那么认为该服务器会被认为是停机了。</td>
</tr>
<tr>
<td align="left">max_conns</td>
<td align="left">允许最大连接数</td>
</tr>
<tr>
<td align="left">fail_time</td>
<td align="left">服务器会被认为停机的时间长度,默认为10s</td>
</tr>
<tr>
<td align="left">backup</td>
<td align="left">标记该服务器为备用服务器，当主服务器停止时，请求会被发送到它这里。</td>
</tr>
<tr>
<td align="left">down</td>
<td align="left">标记服务器永久停机了</td>
</tr>
<tr>
<td align="left">slow_start</td>
<td align="left">当节点恢复，不立即加入</td>
</tr>
</tbody></table>
<h1 id="16、重试策略"><a href="#16、重试策略" class="headerlink" title="16、重试策略"></a>16、重试策略</h1><h2 id="16-1、服务不可用重试"><a href="#16-1、服务不可用重试" class="headerlink" title="16.1、服务不可用重试"></a>16.1、服务不可用重试</h2><p>关于重试策略我们这里也说一下，重试是在发生错误时的一种不可缺少的手段，这样当某一个或者某几个服务宕机时（因为我们现在大多都是多实例部署），如果有正常服务，那么将请求 重试到正常服务的机器上去。</p>
<p>下边我们先修改下nginx.conf文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream mybackendserver &#123;</span><br><span class="line">    # 60秒内 如果请求8081端口这个应用失败</span><br><span class="line">    # 3次，则认为该应用宕机 时间到后再有请求进来继续尝试连接宕机应用且仅尝试 1 次，如果还是失败，</span><br><span class="line">    # 则继续等待 60 秒...以此循环，直到恢复</span><br><span class="line">    server 172.30.128.64:8081 fail_timeout=60s max_fails=3; </span><br><span class="line">    </span><br><span class="line">    server 172.30.128.64:8082;</span><br><span class="line">    server 172.30.128.64:8083;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)image.png</p>
<h2 id="16-2、错误重试"><a href="#16-2、错误重试" class="headerlink" title="16.2、错误重试"></a>16.2、错误重试</h2><p>错误重试是你可以配置哪些状态下  才会执行重试，比如如下这个配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> # 指定哪些错误状态才执行 重试 比如下边的 error 超时，500,502,503 504</span><br><span class="line">proxy_next_upstream error timeout http_500 http_502 http_503 http_504;</span><br></pre></td></tr></table></figure>

<p>接下来我们使用idea启动8082端口，然后打个断点让8082这个服务超时（验证下超时重试），效果如下：![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)可以看到8082因为超时，重试给8081 然后8081也不可用重试给8083 最终8083返回数据。</p>
<h2 id="16-3、关于backup"><a href="#16-3、关于backup" class="headerlink" title="16.3、关于backup"></a>16.3、关于backup</h2><p>Nginx 支持设置备用节点，当所有线上节点都异常时会启用备用节点，同时备用节点也会影响到失败 重试的逻辑。</p>
<p>我们可以通过 backup 指令来定义备用服务器，backup有如下特征：</p>
<ol>
<li>正常情况下，请求不会转到到 backup 服务器，包括失败重试的场景</li>
<li>当所有正常节点全部不可用时，backup 服务器生效，开始处理请求</li>
<li>一旦有正常节点恢复，就使用已经恢复的正常节点</li>
<li>backup 服务器生效期间，不会存在所有正常节点一次性恢复的逻辑</li>
<li>如果全部 backup 服务器也异常，则会将所有节点一次性恢复，加入存活列表</li>
<li>如果全部节点（包括 backup）都异常了，则 Nginx 返回 502 错误</li>
</ol>
<p>接着我们修改下nginx.conf文件演示下backup的作用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream mybackendserver &#123;</span><br><span class="line">    server 172.30.128.64:8081 fail_timeout=60s max_fails=3; # 60秒内 如果请求某一个应用失败3次，则认为该应用宕机 时间到后再有请求进来继续尝试连接宕机应用且仅尝试 1 次，如果还是失败，则继续等待 60 秒...以此循环，直到恢复</span><br><span class="line">    server 172.30.128.64:8082;</span><br><span class="line">    server 172.30.128.64:8083 backup; # 设置8083位备机</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)image.png</p>
<p>之后我们启动8081 8082 8083 三个服务，然后先停掉8081 再停掉8082 看看效果：</p>
<p>![图片](data:image&#x2F;svg+xml,%3C%3Fxml version&#x3D;’1.0’ encoding&#x3D;’UTF-8’%3F%3E%3Csvg width&#x3D;’1px’ height&#x3D;’1px’ viewBox&#x3D;’0 0 1 1’ version&#x3D;’1.1’ xmlns&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>‘ xmlns:xlink&#x3D;’<a target="_blank" rel="noopener" href="http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg">http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg</a> stroke&#x3D;’none’ stroke-width&#x3D;’1’ fill&#x3D;’none’ fill-rule&#x3D;’evenodd’ fill-opacity&#x3D;’0’%3E%3Cg transform&#x3D;’translate(-249.000000, -126.000000)’ fill&#x3D;’%23FFFFFF’%3E%3Crect x&#x3D;’249’ y&#x3D;’126’ width&#x3D;’1’ height&#x3D;’1’%3E%3C&#x2F;rect%3E%3C&#x2F;g%3E%3C&#x2F;g%3E%3C&#x2F;svg%3E)可以看到即使8081 不可用也只是去8082重试而不会到备机重试，如果8081 8082都不可用则请求重试到备机：8083</p>
<h1 id="17、最后"><a href="#17、最后" class="headerlink" title="17、最后"></a>17、最后</h1><p>为了方便粘贴以及观察，这里贴出我机器上完整的 nginx.conf文件，如下：</p>
<h2 id="17-1、贴出完整nginx-conf文件"><a href="#17-1、贴出完整nginx-conf文件" class="headerlink" title="17.1、贴出完整nginx.conf文件"></a>17.1、贴出完整nginx.conf文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log notice;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # log_format  debug  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">    #</span><br><span class="line">    log_format  debug  &#x27; $remote_user [$time_local]  $http_x_Forwarded_for $remote_addr  $request &#x27;  </span><br><span class="line">                      &#x27;$http_x_forwarded_for &#x27;  </span><br><span class="line">                      &#x27;$upstream_addr &#x27;  </span><br><span class="line">                      &#x27;ups_resp_time: $upstream_response_time &#x27;  </span><br><span class="line">                      &#x27;request_time: $request_time&#x27;; </span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  debug;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    upstream mybackendserver &#123;</span><br><span class="line">        server 172.30.128.64:8081 fail_timeout=60s max_fails=3; # 60秒内 如果请求某一个应用失败3次，则认为该应用宕机 时间到后再有请求进来继续尝试连接宕机应用且仅尝试 1 次，如果还是失败，则继续等待 60 秒...以此循环，直到恢复</span><br><span class="line">        server 172.30.128.64:8082;</span><br><span class="line">        server 172.30.128.64:8083 backup; # 设置8083位备机</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     # 开启/关闭 压缩机制</span><br><span class="line">    gzip on;</span><br><span class="line">    # 根据文件类型选择 是否开启压缩机制</span><br><span class="line">    gzip_types text/plain application/javascript text/css application/xml text/javascript image/jpeg image/jpg image/gif image/png  application/json;</span><br><span class="line">    # 设置压缩级别，越高资源消耗越大越耗时，但压缩效果越好</span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    # 设置是否携带Vary:Accept-Encoding 的响应头</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    # 处理压缩请求的 缓冲区数量和大小</span><br><span class="line">    gzip_buffers 32 64k;</span><br><span class="line">    # 对于不支持压缩功能的客户端请求 不开启压缩机制</span><br><span class="line">    gzip_disable &quot;MSIE [1-6]\.&quot;; # 比如低版本的IE浏览器不支持压缩</span><br><span class="line">    # 设置压缩功能所支持的HTTP最低版本</span><br><span class="line">    gzip_http_version 1.1;</span><br><span class="line">    # 设置触发压缩的最小阈值</span><br><span class="line">    gzip_min_length 2k;</span><br><span class="line">    # off/any/expired/no-cache/no-store/private/no_last_modified/no_etag/auth 根据不同配置对后端服务器的响应结果进行压缩</span><br><span class="line">    gzip_proxied any;</span><br><span class="line"></span><br><span class="line">    # 指定缓存存放目录为/usr/local/nginx/test/nginx_cache_storage，并设置缓存名称为mycache，大小为64m， 1天未被访问过的缓存将自动清除，磁盘中缓存的最大容量为1gb</span><br><span class="line">    proxy_cache_path /usr/local/nginx/test/nginx_cache_storage levels=1:2 keys_zone=mycache:64m inactive=1d max_size=1g;</span><br><span class="line">    # 对请求速率限流</span><br><span class="line">    #limit_req_zone $binary_remote_addr zone=myRateLimit:10m rate=5r/s;</span><br><span class="line">    # 对请求连接数限流</span><br><span class="line">    limit_conn_zone $binary_remote_addr zone=myConnLimit:10m; </span><br><span class="line">    </span><br><span class="line">    # --------------------HTTP 演示 配置---------------------</span><br><span class="line">    server &#123;</span><br><span class="line">      listen 80 default;</span><br><span class="line">      charset utf-8;</span><br><span class="line">      server_name www.hzznb-xzll.xyz hzznb-xzll.xyz;</span><br><span class="line"></span><br><span class="line">      #location /static/ &#123;</span><br><span class="line">      #    root /usr/local/nginx/test;  # /usr/local/nginx/test/static/xxx.jpg</span><br><span class="line">      #&#125;</span><br><span class="line"></span><br><span class="line">      location /static &#123; # 注意一般 alias的 url都不带后边的/ </span><br><span class="line">          alias /usr/local/nginx/test/; # 使用alias时  这里的目录最后边一定要加/ 否则就404</span><br><span class="line">      &#125;</span><br><span class="line">      # 测试autoindex效果</span><br><span class="line">      location /book/ &#123;</span><br><span class="line">          root /usr/local/nginx/test;</span><br><span class="line">          autoindex on; # 打开 autoindex，，可选参数有 on | off</span><br><span class="line">          autoindex_format html; # 以html的方式进行格式化，可选参数有 html | json | xml</span><br><span class="line">          autoindex_exact_size on; # 修改为off，会以KB、MB、GB显示文件大小，默认为on以bytes显示出⽂件的确切⼤⼩</span><br><span class="line">          autoindex_localtime off; # 显示⽂件时间 GMT格式</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      # 临时重定向</span><br><span class="line">      location /temp_redir &#123;</span><br><span class="line">          rewrite ^/(.*) https://www.baidu.com redirect;</span><br><span class="line">      &#125;</span><br><span class="line">      # 永久重定向</span><br><span class="line">      location /forever_redir &#123;</span><br><span class="line">          </span><br><span class="line">          rewrite ^/(.*) https://www.baidu.com permanent;</span><br><span class="line">      &#125;</span><br><span class="line">      # rewrite last规则测试</span><br><span class="line">      location /1 &#123;</span><br><span class="line">        rewrite /1/(.*) /2/$1 last;</span><br><span class="line">      &#125;</span><br><span class="line">      location /2 &#123;</span><br><span class="line">        rewrite /2/(.*) /3/$1 last;</span><br><span class="line">      &#125;</span><br><span class="line">      location /3 &#123;</span><br><span class="line">        alias  &#x27;/usr/local/nginx/test/static/&#x27;;</span><br><span class="line">        index location_last_test.html; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # --------------------HTTP配置---------------------</span><br><span class="line">    server &#123;</span><br><span class="line">      listen 80;</span><br><span class="line">      charset utf-8;</span><br><span class="line">      #server_name www.xxxadminsystem.com;</span><br><span class="line">      server_name www.hzznbc-xzll.xyz hzznbc-xzll.xyz;</span><br><span class="line">      # 重定向，会显示跳转的地址server_name,如果访问的地址没有匹配会默认使用第一个，即www.likeong.icu</span><br><span class="line">      return 301 https://$server_name$request_uri;</span><br><span class="line"></span><br><span class="line">        # # 指定 username 参数中只要有字母 就不走nginx缓存  </span><br><span class="line">        # if ($arg_username ~ [a-z]) &#123;</span><br><span class="line">        #     set $cache_name &quot;no cache&quot;;</span><br><span class="line">        # &#125;</span><br><span class="line">        # # 前端页面资源</span><br><span class="line">        # location  /page &#123;</span><br><span class="line">        #   alias  &#x27;/usr/local/nginx/test/static/&#x27;;</span><br><span class="line">        #   index index_page.html; </span><br><span class="line"></span><br><span class="line">        #   allow all;</span><br><span class="line">        # &#125;</span><br><span class="line">        # # 后端服务</span><br><span class="line">        # location  /interface &#123;</span><br><span class="line">        #   proxy_pass http://mybackendserver/;</span><br><span class="line">        #   # 使用名为 mycache 的缓存空间</span><br><span class="line">        #   proxy_cache mycache;</span><br><span class="line">        #   # 对于200 206 状态码的数据缓存2分钟</span><br><span class="line">        #   proxy_cache_valid 200 206 1m;</span><br><span class="line">        #   # 定义生成缓存键的规则（请求的url+参数作为缓存key）</span><br><span class="line">        #   proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">        #   # 资源至少被重复访问2次后再加入缓存</span><br><span class="line">        #   proxy_cache_min_uses 3;</span><br><span class="line">        #   # 出现重复请求时，只让其中一个去后端读数据，其他的从缓存中读取</span><br><span class="line">        #   proxy_cache_lock on;</span><br><span class="line">        #   # 上面的锁 超时时间为4s，超过4s未获取数据，其他请求直接去后端</span><br><span class="line">        #   proxy_cache_lock_timeout 4s;</span><br><span class="line">        #   # 对于请求参数中有字母的 不走nginx缓存</span><br><span class="line">        #   proxy_no_cache $cache_name; # 判断该变量是否有值，如果有值则不进行缓存，没有值则进行缓存</span><br><span class="line">        #   # 在响应头中添加一个缓存是否命中的状态（便于调试）</span><br><span class="line">        #   add_header Cache-status $upstream_cache_status;</span><br><span class="line">          </span><br><span class="line">        #   limit_conn myConnLimit 12;</span><br><span class="line"></span><br><span class="line">        # limit_req zone=myRateLimit burst=5  nodelay;</span><br><span class="line">        # limit_req_status 520;</span><br><span class="line">        # limit_req_log_level info;</span><br><span class="line">        #&#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # --------------------HTTPS 配置---------------------</span><br><span class="line">    server &#123;</span><br><span class="line">        #SSL 默认访问端口号为 443</span><br><span class="line">        listen 443 ssl; </span><br><span class="line">        #填写绑定证书的域名 </span><br><span class="line">        server_name www.hzznb-xzll.xyz hzznb-xzll.xyz; </span><br><span class="line">        #请填写证书文件的相对路径或绝对路径</span><br><span class="line">        ssl_certificate /usr/local/nginx/certificate/hzznb-xzll.xyz_bundle.crt; </span><br><span class="line">        #请填写私钥文件的相对路径或绝对路径</span><br><span class="line">        ssl_certificate_key /usr/local/nginx/certificate/hzznb-xzll.xyz.key; </span><br><span class="line">        #停止通信时，加密会话的有效期，在该时间段内不需要重新交换密钥</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        #服务器支持的TLS版本</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; </span><br><span class="line">        #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; </span><br><span class="line">        #开启由服务器决定采用的密码套件</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        </span><br><span class="line">        # 指定 username 参数中只要有字母 就不走nginx缓存  </span><br><span class="line">        if ($arg_username ~ [a-z]) &#123;</span><br><span class="line">            set $cache_name &quot;no cache&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        # 前端页面资源</span><br><span class="line">        location  /page &#123;</span><br><span class="line">          alias  &#x27;/usr/local/nginx/test/static/&#x27;;</span><br><span class="line">          index index_page.html; </span><br><span class="line"></span><br><span class="line">          allow all;</span><br><span class="line">        &#125;</span><br><span class="line">        # 后端服务</span><br><span class="line">        location  /interface &#123;</span><br><span class="line">          proxy_pass http://mybackendserver/;</span><br><span class="line"></span><br><span class="line">          # 指定哪些错误状态才执行 重试</span><br><span class="line">          proxy_next_upstream error timeout http_500 http_502 http_503 http_504 http_404;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          # 使用名为 mycache 的缓存空间</span><br><span class="line">          proxy_cache mycache;</span><br><span class="line">          # 对于200 206 状态码的数据缓存2分钟</span><br><span class="line">          proxy_cache_valid 200 206 1m;</span><br><span class="line">          # 定义生成缓存键的规则（请求的url+参数作为缓存key）</span><br><span class="line">          proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">          # 资源至少被重复访问2次后再加入缓存</span><br><span class="line">          proxy_cache_min_uses 3;</span><br><span class="line">          # 出现重复请求时，只让其中一个去后端读数据，其他的从缓存中读取</span><br><span class="line">          proxy_cache_lock on;</span><br><span class="line">          # 上面的锁 超时时间为4s，超过4s未获取数据，其他请求直接去后端</span><br><span class="line">          proxy_cache_lock_timeout 4s;</span><br><span class="line">          # 对于请求参数中有字母的 不走nginx缓存</span><br><span class="line">          proxy_no_cache $cache_name; # 判断该变量是否有值，如果有值则不进行缓存，没有值则进行缓存</span><br><span class="line">          # 在响应头中添加一个缓存是否命中的状态（便于调试）</span><br><span class="line">          add_header Cache-status $upstream_cache_status;</span><br><span class="line">          </span><br><span class="line">          limit_conn myConnLimit 12;</span><br><span class="line"></span><br><span class="line">        # limit_req zone=myRateLimit burst=5  nodelay;</span><br><span class="line">        # limit_req_status 520;</span><br><span class="line">        # limit_req_log_level info;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        # 后端服务</span><br><span class="line">        location  /interface2 &#123;</span><br><span class="line">          proxy_pass http://mybackendserver;</span><br><span class="line">          # 使用名为 mycache 的缓存空间</span><br><span class="line">          proxy_cache mycache;</span><br><span class="line">          # 对于200 206 状态码的数据缓存2分钟</span><br><span class="line">          proxy_cache_valid 200 206 1m;</span><br><span class="line">          # 定义生成缓存键的规则（请求的url+参数作为缓存key）</span><br><span class="line">          proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">          # 资源至少被重复访问2次后再加入缓存</span><br><span class="line">          proxy_cache_min_uses 3;</span><br><span class="line">          # 出现重复请求时，只让其中一个去后端读数据，其他的从缓存中读取</span><br><span class="line">          proxy_cache_lock on;</span><br><span class="line">          # 上面的锁 超时时间为4s，超过4s未获取数据，其他请求直接去后端</span><br><span class="line">          proxy_cache_lock_timeout 4s;</span><br><span class="line">          # 对于请求参数中有字母的 不走nginx缓存</span><br><span class="line">          proxy_no_cache $cache_name; # 判断该变量是否有值，如果有值则不进行缓存，没有值则进行缓存</span><br><span class="line">          # 在响应头中添加一个缓存是否命中的状态（便于调试）</span><br><span class="line">          add_header Cache-status $upstream_cache_status;</span><br><span class="line">          </span><br><span class="line">          limit_conn myConnLimit 12;</span><br><span class="line"></span><br><span class="line">        # limit_req zone=myRateLimit burst=5  nodelay;</span><br><span class="line">        # limit_req_status 520;</span><br><span class="line">        # limit_req_log_level info;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/44ce857c1024a.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/44ce857c1024a.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">晨空</div><div class="post-copyright__author_desc">星辰与大海并非遥不可及</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/05/17/nginx/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/05/17/nginx/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/')">nginx-一篇通</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/05/17/nginx/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=nginx-一篇通&amp;url=http://example.com/2024/05/17/nginx/nginx-%E4%B8%80%E7%AF%87%E9%80%9A/&amp;pic=/tupian/nginx-top.jpeg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">晨空</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/nginx/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>nginx<span class="tagsPageCount">2</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/tupian/hexo-top.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/17/VPS%E8%B4%AD%E4%B9%B0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/tupian/VPS-top.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">VPS购买</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/17/nginx/nginx-%E5%9F%BA%E7%A1%80/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/tupian/nginx-top.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">nginx-基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/05/17/nginx/nginx-%E5%9F%BA%E7%A1%80/" title="nginx-基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/tupian/nginx-top.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-17</div><div class="title">nginx-基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/44ce857c1024a.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">牛马就该做牛马该做的事，其实也可以不做哦</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">晨空</h1><div class="author-info__desc">星辰与大海并非遥不可及</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="/anzhiyu-icon-github" target="_blank" title="Github"></a><a class="social-icon faa-parent animated-hover" href="/anzhiyu-icon-bilibili" target="_blank" title="BiliBili"></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#nginx-%E4%B8%80%E6%8A%8A%E6%A2%AD%EF%BC%81%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3-%E5%AE%9E%E6%93%8D%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">nginx 一把梭！（超详细讲解+实操）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">前言：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81nginx-%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.</span> <span class="toc-text">1、nginx 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81nginx-%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">1.1、nginx 特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E3%80%81nginx-%E6%9E%B6%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">1.2、nginx 架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E3%80%81nginx%E6%A8%A1%E5%9D%97"><span class="toc-number">3.3.</span> <span class="toc-text">1.3、nginx模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4%E3%80%81nginx%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.4.</span> <span class="toc-text">1.4、nginx常见应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81nginx%E5%AE%89%E8%A3%85"><span class="toc-number">4.</span> <span class="toc-text">2、nginx安装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81nginx%E7%9B%AE%E5%BD%95%E4%B8%80%E8%A7%88"><span class="toc-number">5.</span> <span class="toc-text">3、nginx目录一览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81nginx-conf%E6%96%87%E4%BB%B6-%E8%A7%A3%E8%AF%BB"><span class="toc-number">6.</span> <span class="toc-text">4、nginx.conf文件 解读</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81localtion-%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">7.</span> <span class="toc-text">5、localtion 路由匹配规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%EF%BC%88%E6%97%A0%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">5.1、前缀匹配（无修饰符）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D%EF%BC%88-%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">5.2、精确匹配（ &#x3D; ）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%EF%BC%88-%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">5.3、前缀匹配（ ^~ ）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E3%80%81%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%EF%BC%88-%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">5.4、正则匹配（~ 区分大小写）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5%E3%80%81%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%EF%BC%88-%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">5.5、正则匹配（~* 不区分大小写）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6%E3%80%81%E9%80%9A%E7%94%A8%E5%8C%B9%E9%85%8D%EF%BC%88-%EF%BC%89"><span class="toc-number">7.6.</span> <span class="toc-text">5.6、通用匹配（ &#x2F; ）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7%E3%80%81%E5%85%B3%E4%BA%8Elocation-%E5%8C%B9%E9%85%8D%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">7.7.</span> <span class="toc-text">5.7、关于location 匹配优先级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">6、反向代理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81%E6%9C%8D%E5%8A%A1%E5%87%86%E5%A4%87"><span class="toc-number">8.1.</span> <span class="toc-text">6.1、服务准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81%E4%BF%AE%E6%94%B9nginx-conf%E6%96%87%E4%BB%B6"><span class="toc-number">8.2.</span> <span class="toc-text">6.2、修改nginx.conf文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E3%80%81%E6%B5%8B%E8%AF%95%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">8.3.</span> <span class="toc-text">6.3、测试反向代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4%E3%80%81%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">8.4.</span> <span class="toc-text">6.4、反向代理流程与原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">9.</span> <span class="toc-text">7、负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81%E5%87%86%E5%A4%873%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%AB%AF%E5%8F%A3%E7%9A%84springboot%E6%9C%8D%E5%8A%A1"><span class="toc-number">9.1.</span> <span class="toc-text">7.1、准备3个不同端口的springboot服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E3%80%81nginx%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B4%9F%E8%BD%BD%E7%AD%96%E7%95%A5"><span class="toc-number">9.2.</span> <span class="toc-text">7.2、nginx常用的负载策略:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1%E3%80%81%E8%BD%AE%E8%AF%A2"><span class="toc-number">9.2.1.</span> <span class="toc-text">7.2.1、轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2%E3%80%81weight"><span class="toc-number">9.2.2.</span> <span class="toc-text">7.2.2、weight</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3%E3%80%81ip-hash"><span class="toc-number">9.2.3.</span> <span class="toc-text">7.2.3、ip_hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4%E3%80%81least-conn"><span class="toc-number">9.2.4.</span> <span class="toc-text">7.2.4、least_conn</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB"><span class="toc-number">10.</span> <span class="toc-text">8、动静分离</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1%E3%80%81%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">10.1.</span> <span class="toc-text">8.1、准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2%E3%80%81%E4%BF%AE%E6%94%B9nginx-conf%E6%96%87%E4%BB%B6"><span class="toc-number">10.2.</span> <span class="toc-text">8.2、修改nginx.conf文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3%E3%80%81%E6%BC%94%E7%A4%BA"><span class="toc-number">10.3.</span> <span class="toc-text">8.3、演示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81%E8%B7%A8%E5%9F%9F"><span class="toc-number">11.</span> <span class="toc-text">9、跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1%E3%80%81%E4%B8%BA%E4%BD%95%E4%BC%9A%E4%BA%A7%E7%94%9F%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">9.1、为何会产生跨域？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2%E3%80%81%E8%B7%A8%E5%9F%9F%E6%BC%94%E7%A4%BA"><span class="toc-number">11.2.</span> <span class="toc-text">9.2、跨域演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3%E3%80%81nginx%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F"><span class="toc-number">11.3.</span> <span class="toc-text">9.3、nginx解决跨域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E3%80%81%E7%BC%93%E5%AD%98"><span class="toc-number">12.</span> <span class="toc-text">10、缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1%E3%80%81nginx%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E8%A1%A8%E6%A0%BC%E4%B8%80%E8%A7%88"><span class="toc-number">12.1.</span> <span class="toc-text">10.1、nginx缓存配置参数表格一览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2%E3%80%81nginx%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA"><span class="toc-number">12.2.</span> <span class="toc-text">10.2、nginx缓存使用与效果演示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E3%80%81%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95"><span class="toc-number">13.</span> <span class="toc-text">11、黑白名单</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1%E3%80%81%E8%AF%AD%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">13.1.</span> <span class="toc-text">11.1、语法作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2%E3%80%81%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E6%BC%94%E7%A4%BA"><span class="toc-number">13.2.</span> <span class="toc-text">11.2、黑白名单演示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E3%80%81nginx%E9%99%90%E6%B5%81"><span class="toc-number">14.</span> <span class="toc-text">12、nginx限流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1%E3%80%81nginx%E9%99%90%E6%B5%81%E9%85%8D%E7%BD%AE%E8%A7%A3%E9%87%8A"><span class="toc-number">14.1.</span> <span class="toc-text">12.1、nginx限流配置解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2%E3%80%81nginx%E9%99%90%E6%B5%81%EF%BC%88%E9%92%88%E5%AF%B9%E8%AF%B7%E6%B1%82%E9%80%9F%E7%8E%87%EF%BC%89"><span class="toc-number">14.2.</span> <span class="toc-text">12.2、nginx限流（针对请求速率）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-1%E3%80%81%E9%99%90%E5%88%B6%E6%AF%8F%E7%A7%92%E5%90%8C%E4%B8%80ip%E6%9C%80%E5%A4%9A%E8%AE%BF%E9%97%AE5%E6%AC%A1-1s"><span class="toc-number">14.2.1.</span> <span class="toc-text">12.2.1、限制每秒同一ip最多访问5次&#x2F;1s</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-2%E3%80%81%E6%89%93%E5%BC%80burst%E5%8F%82%E6%95%B0%E5%B9%B6%E8%AE%BE%E7%BD%AE%E6%88%905"><span class="toc-number">14.2.2.</span> <span class="toc-text">12.2.2、打开burst参数并设置成5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-3%E3%80%81%E6%89%93%E5%BC%80nodelay"><span class="toc-number">14.2.3.</span> <span class="toc-text">12.2.3、打开nodelay</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3%E3%80%81nginx%E9%99%90%E6%B5%81%EF%BC%88%E9%92%88%E5%AF%B9%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%87%8F%EF%BC%89"><span class="toc-number">14.3.</span> <span class="toc-text">12.3、nginx限流（针对连接数量）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13%E3%80%81https%E9%85%8D%E7%BD%AE"><span class="toc-number">15.</span> <span class="toc-text">13、https配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1%E3%80%81https-ssl%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85"><span class="toc-number">15.1.</span> <span class="toc-text">13.1、https_ssl模块安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2%E3%80%81%E5%9F%9F%E5%90%8D%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-ssl%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%AA%8C%E8%AF%81"><span class="toc-number">15.2.</span> <span class="toc-text">13.2、域名购买&amp;解析&amp;ssl证书申请与验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3%E3%80%81%E4%B8%8A%E4%BC%A0%E5%B9%B6%E9%85%8D%E7%BD%AEnginx%E4%BB%A5%E5%8F%8A%E6%BC%94%E7%A4%BA"><span class="toc-number">15.3.</span> <span class="toc-text">13.3、上传并配置nginx以及演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4%E3%80%81http%E8%B7%B3%E8%BD%AChttps"><span class="toc-number">15.4.</span> <span class="toc-text">13.4、http跳转https</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14%E3%80%81%E5%8E%8B%E7%BC%A9"><span class="toc-number">16.</span> <span class="toc-text">14、压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1%E3%80%81%E5%8E%8B%E7%BC%A9%E5%89%8D"><span class="toc-number">16.1.</span> <span class="toc-text">14.1、压缩前</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2%E3%80%81%E5%8E%8B%E7%BC%A9%E5%90%8E"><span class="toc-number">16.2.</span> <span class="toc-text">14.2、压缩后</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15%E3%80%81%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E6%AF%94%E8%BE%83%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%AF%B4%E6%98%8E"><span class="toc-number">17.</span> <span class="toc-text">15、其他一些比较常用的指令与说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1%E3%80%81rewrite"><span class="toc-number">17.1.</span> <span class="toc-text">15.1、rewrite</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2%E3%80%81if"><span class="toc-number">17.2.</span> <span class="toc-text">15.2、if</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-3%E3%80%81nginx%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">17.3.</span> <span class="toc-text">15.3、nginx全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4%E3%80%81auto-index"><span class="toc-number">17.4.</span> <span class="toc-text">15.4、auto_index</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-5%E3%80%81root-alias"><span class="toc-number">17.5.</span> <span class="toc-text">15.5、root&amp;alias</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-5-1%E3%80%81root"><span class="toc-number">17.5.1.</span> <span class="toc-text">15.5.1、root</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-5-2%E3%80%81alias"><span class="toc-number">17.5.2.</span> <span class="toc-text">15.5.2、alias</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-5-3%E3%80%81proxy-pass-%E4%B8%AD%E7%9A%84%E6%96%9C%E7%BA%BF%E4%B8%8Eroot%E5%92%8C-alias%E7%9A%84%E7%9B%B8%E4%BC%BC%E4%B9%8B%E5%A4%84"><span class="toc-number">17.5.3.</span> <span class="toc-text">15.5.3、proxy_pass 中的斜线与root和 alias的相似之处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-6%E3%80%81upstream-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">17.6.</span> <span class="toc-text">15.6、upstream 中常用的几个指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16%E3%80%81%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5"><span class="toc-number">18.</span> <span class="toc-text">16、重试策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1%E3%80%81%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%8F%AF%E7%94%A8%E9%87%8D%E8%AF%95"><span class="toc-number">18.1.</span> <span class="toc-text">16.1、服务不可用重试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2%E3%80%81%E9%94%99%E8%AF%AF%E9%87%8D%E8%AF%95"><span class="toc-number">18.2.</span> <span class="toc-text">16.2、错误重试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-3%E3%80%81%E5%85%B3%E4%BA%8Ebackup"><span class="toc-number">18.3.</span> <span class="toc-text">16.3、关于backup</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17%E3%80%81%E6%9C%80%E5%90%8E"><span class="toc-number">19.</span> <span class="toc-text">17、最后</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-1%E3%80%81%E8%B4%B4%E5%87%BA%E5%AE%8C%E6%95%B4nginx-conf%E6%96%87%E4%BB%B6"><span class="toc-number">19.1.</span> <span class="toc-text">17.1、贴出完整nginx.conf文件</span></a></li></ol></li></ol></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 By <a class="footer-bar-link" href="/" title="晨空" target="_blank">晨空</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-一篇通/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/nginx-一篇通/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CICD/" style="font-size: 0.88rem;">CICD<sup>1</sup></a><a href="/tags/K8S/" style="font-size: 0.88rem;">K8S<sup>1</sup></a><a href="/tags/VPN/" style="font-size: 0.88rem;">VPN<sup>1</sup></a><a href="/tags/hexo/" style="font-size: 0.88rem;">hexo<sup>2</sup></a><a href="/tags/nginx/" style="font-size: 0.88rem;">nginx<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("05/20/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2024 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 晨空 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="运维"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>